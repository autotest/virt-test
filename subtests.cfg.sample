# Copy this file to subtests.cfg and edit it.
#
# Subtests
variants:
    - install:
        no RHEL
        no e1000
        no virtio_nic
        type = steps
        fail_if_stuck_for = 300
        stuck_detection_history = 2
        keep_screendump_history = yes
        force_create_image = yes
        kill_vm = yes
        kill_vm_timeout = 60
        kill_vm_timeout_on_error = 0

    - setup: install
        no Linux
        no e1000
        no virtio_nic
        type = steps
        fail_if_stuck_for = 300
        stuck_detection_history = 2
        kill_vm_on_error = yes
        keep_screendump_history = yes

    - image_copy:
        type = image_copy
        vms = ''
        parallel = no
        profilers =

    - unattended_install:
        type = unattended_install
        start_vm = no
        kill_vm = yes
        kill_vm_gracefully = yes
        kill_vm_on_error = yes
        start_vm = no
        shutdown_cleanly = no
        shutdown_cleanly_timeout = 120
        force_create_image = yes
        #pre_command = "scripts/unattended.py;"
        #post_command = "scripts/private_br.sh;"
        #bridge = vbr0
        #nic_script = scripts/qemu-ifup-vbr0
        guest_port_unattended_install = 12323
        kernel = vmlinuz
        initrd = initrd.img
        nic_mode = tap
        PAE:
            type = image_copy
            vms = ''
            parallel = no
            profilers =
            pre_command =
            post_command =
        variants:
            aio_native:
                image_aio = native
            aio_threads:
                image_aio = threads
        variants:
            @default_install:
            multi_disk_install:
                no ide
                only unattended_install.cdrom
                images += " stg stg2 stg3 stg4 stg5 stg6 stg7 stg8 stg9 stg10 stg11 stg12 stg13 stg14 stg15 stg16 stg17 stg18 stg19 stg20 stg21 stg22 stg23 stg24"
                image_name_stg = storage
                image_name_stg2 = storage2
                image_name_stg3 = storage3
                image_name_stg4 = storage4
                image_name_stg5 = storage5
                image_name_stg6 = storage6
                image_name_stg7 = storage7
                image_name_stg8 = storage8
                image_name_stg9 = storage9
                image_name_stg10 = storage10
                image_name_stg11 = storage11
                image_name_stg12 = storage12
                image_name_stg13 = storage13
                image_name_stg14 = storage14
                image_name_stg15 = storage15
                image_name_stg16 = storage16
                image_name_stg17 = storage17
                image_name_stg18 = storage18
                image_name_stg19 = storage19
                image_name_stg20 = storage20
                image_name_stg21 = storage21
                image_name_stg22 = storage22
                image_name_stg23 = storage23
                image_name_stg24 = storage24
                image_name_stg25 = storage25
            large_image:
                only unattended_install.cdrom
                only qcow2
                image_size_image1 = 2300G
                image_size = 2300G
                cluster_size = 512
            with_migration:
                migrate_background = yes
        variants:
            # Install guest from cdrom
            - cdrom:
                medium = cdrom
                installation = cdrom
                #redirs += " unattended_install"
                Linux:
                    image_size_image1 = 20G
                    image_size = 5G
                Windows:
                    image_size_image1 = 30G
                    image_size = 5G
            # Install guest from http/ftp url
            - url:
                only Linux
                medium = url
                url = REPLACE_THIS_WITH_TREE_URL
                installation = net
            # Install guest from nfs nfs_server:nfs_dir
            - nfs:
                only Linux
                medium = nfs
                nfs_server = REPLACE_THIS_WITH_NFS_SERVER
                nfs_dir = REPLACE_THIS_WITH_NFS_DIRECTORY
                installation = net
            # Install guest with a remote kickstart
            #- remote_ks:
            #    only Linux
            #    medium = url
            #    extra_params = " --append ks=REPLACE_THIS_WITH_URL_OF_KS"
            #    url = REPLACE_THIS_WITH_TREE_URL
            # Install guest using pxe/tftp  (virt-install --pxe)
            #- pxe:
            #    only Linux
            #    medium = pxe
            # Install guest using kernel/initrd pair from directory
            #- kernel_initrd:
            #    only Linux
            #    medium = kernel_initrd


    - qemu_img:
        type = qemu_img
        vms = ''
        profilers = ''
        images = ''
        take_regular_screendumps = no
        variants:
            - check:
                subcommand = check
                image_name_dd = dd_created_image
                force_create_image_dd = no
                remove_image_dd = yes
                create_image_cmd = "dd if=/dev/zero of=%s bs=1G count=1"
                # Test the convertion from 'dd_image_name' to specified format
                supported_image_formats = qcow2 raw
            - create:
                subcommand = create
                images += " large"
                force_create_image_large = yes
                image_size_large = 2G
                image_name_large = create_large_image
                remove_image_large = yes
                variants:
                    - non-preallocated:
                        variants:
                            - cluster_512:
                                cluster_size = 512
                            - cluster_1024:
                                cluster_size = 1024
                            - cluster_4096:
                                cluster_size = 4096
                            - cluster_1M:
                                cluster_size = 1M
                            - cluster_2M:
                                cluster_size = 2M
                    - preallocated:
                        no raw
                        preallocated = yes
                        variants:
                            - file:
                            - over_lvm:
                                pre_command += " qemu-img create -f raw 0.raw 10G && qemu-img create -f raw 1.raw 10G && losetup /dev/loop0 0.raw && losetup /dev/loop1 1.raw && pvcreate /dev/loop0 /dev/loop1 && vgcreate vg /dev/loop0 /dev/loop1 && lvcreate -L 19G -n lv vg"
                                device = /dev/vg/lv
                                image_size_large = 18G
                                post_command += " lvremove -f vg ; losetup -d /dev/loop0 ; losetup -d /dev/loop1; rm -rf /dev/vg; rm -rf *.raw;"
                                pre_command_noncritical = no
                                post_command_noncritical = no
            - convert:
                subcommand = convert
                images = image1
                variants:
                    - to_qcow2:
                        dest_image_format = qcow2
                        compressed = no
                        encrypted = no
                    - to_raw:
                        dest_image_format = raw
            - snapshot:
                subcommand = snapshot
                only qcow2
            - commit:
                images = image1
                subcommand = commit
            - info:
                subcommand = info
            - rebase:
                subcommand = rebase
                images = image1
                rebase_mode = unsafe
                image_name_snapshot1 = sn1
                image_name_snapshot2 = sn2

    - pxe:
        type = pxe
        images = pxe
        image_name_pxe = pxe-test
        image_size_pxe = 1G
        force_create_image_pxe = yes
        remove_image_pxe = yes
        boot_once = n
        kill_vm_on_error = yes
        network = bridge
        restart_vm = yes
        pxe_timeout = 60
        variants:
            - etherboot:
                pre_command = "alternatives --display qemu-pxe-roms |grep -q etherboot && alternatives --set 'qemu-pxe-roms' /usr/share/etherboot || true"
                no Host_RHEL.6
            - gpxe:
                pre_command = "alternatives --display qemu-pxe-roms |grep -q gpxe || alternatives --install /usr/share/qemu-pxe-roms qemu-pxe-roms /usr/share/gpxe 1; alternatives --set 'qemu-pxe-roms' /usr/share/gpxe"

    - module_probe:
        type = module_probe
        load_count = 10
        vms = ""

# Tests that do need installed guests to run
    - boot:
        type = boot
        kill_vm_on_error = yes
        login_timeout = 240

    - boot_with_usb:
        no Host_RHEL.5
        no Host_RHEL.6.1
        type = boot
        restart_vm = yes
        kill_vm_on_error = yes
        login_timeout = 240
        variants:
            - ehci:
                # Disable other usb devices
                usb_devices = ""
                usbs = usb1
                usb_type_usb1 = usb-ehci
                usb_max_port_usb1 = 6
                check_func = "check_usb_device"
                info_usb_name = ""
                vendor_id = "1d6b"
                vendor = "Linux Foundation"
                product_id = "0002"
                product = "EHCI Host Controller"
            - keyboard:
                usb_devices = kbd1
                usb_type_kbd1 = usb-kbd
                usb_controller_kbd1 = uhci
                check_func = "check_usb_device"
                info_usb_name = "QEMU USB Keyboard"
                vendor_id = "0627"
                vendor = "Adomax Technology Co., Ltd"
                product_id = "0001"
                product = "QEMU USB Keyboard"
            - mouse:
                usb_devices = mouse1
                usb_type_mouse1 = usb-mouse
                usb_controller_mouse1 = uhci
                check_func = "check_usb_device"
                info_usb_name = "QEMU USB Mouse"
                vendor_id = "0627"
                vendor = "Adomax Technology Co., Ltd"
                product_id = "0001"
                product = "QEMU USB Mouse"
            - hub:
                usb_devices = hub1
                usb_type_hub1 = usb-hub
                usb_controller_hub1 = uhci
                check_func = "check_usb_device"
                info_usb_name = "QEMU USB Hub"
                vendor_id = "0000"
                vendor = ""
                product_id = "0000"
                product = "QEMU USB Hub"
            - storage:
                # Disable other usb devices
                usb_devices = ""
                usbs = usb1
                usb_type_usb1 = usb-ehci
                usb_max_port_usb1 = 6
                check_func = "check_usb_device"
                info_usb_name = "QEMU USB MSD"
                vendor_id = "0000"
                vendor = ""
                product_id = "0000"
                product = "QEMU USB HARDDRIVE"
                images += " stg"
                image_boot_image1 = yes
                image_name_stg = "usbdevice"
                image_format_stg = "qcow2"
                image_boot_stg = no
                drive_format_stg = "usb2"
                drive_index_stg = 1
                create_image_stg = yes
                image_size_stg = 10M

    - reboot:
        type = boot
        reboot_method = shell
        kill_vm_on_error = yes
        reboot = yes
        reboot_count = 25
        login_timeout = 240
        # this script is used to setup test env for (linux)guest/host
        # before performance testing
        # rh_perf_envsetup_script = scripts/rh_perf_envsetup.sh

    - reboot_with_usb:
        no Host_RHEL.5
        no Host_RHEL.6.1
        type = boot
        reboot_method = shell
        kill_vm_on_error = yes
        login_timeout = 240
        variants:
            - ehci:
                check_func = "check_usb_device"
                # info_usb_name = ""
                vendor_id = "1d6b"
                vendor = "Linux Foundation"
                product_id = "0002"
                product = "EHCI Host Controller"
                # Disable other usb devices
                usb_devices = ""
                usbs = usb1
                usb_type_usb1 = usb-ehci
                usb_max_port_usb1 = 6
            - keyboard:
                usb_devices = kbd1
                usb_type_kbd1 = usb-kbd
                usb_controller_kbd1 = uhci
                check_func = "check_usb_device"
                info_usb_name = "QEMU USB Keyboard"
                vendor_id = "0627"
                vendor = "Adomax Technology Co., Ltd"
                product_id = "0001"
                product = "QEMU USB Keyboard"
            - mouse:
                usb_devices = mouse1
                usb_type_mouse1 = usb-mouse
                usb_controller_mouse1 = uhci
                check_func = "check_usb_device"
                info_usb_name = "QEMU USB Mouse"
                vendor_id = "0627"
                vendor = "Adomax Technology Co., Ltd"
                product_id = "0001"
                product = "QEMU USB Mouse"
            - hub:
                usb_devices = hub1
                usb_type_hub1 = usb-hub
                usb_controller_hub1 = uhci
                check_func = "check_usb_device"
                info_usb_name = "QEMU USB Hub"
                vendor_id = "0000"
                # vendor = ""
                product_id = "0000"
                product = "QEMU USB Hub"
            - storage:
                check_func = "check_usb_device"
                info_usb_name = "QEMU USB MSD"
                vendor_id = "0000"
                # vendor = ""
                product_id = "0000"
                product = "QEMU USB HARDDRIVE"
                # Disable other usb devices
                usb_devices = ""
                usbs = usb1
                usb_type_usb1 = usb-ehci
                usb_max_port_usb1 = 6
                images += " stg"
                image_boot_image1 = yes
                image_name_stg = "usbdevice"
                image_format_stg = "qcow2"
                image_boot_stg = no
                drive_format_stg = "usb2"
                drive_index_stg = 1
                create_image_stg = yes
                image_size_stg = 10M

    - dd_test: install setup image_copy unattended_install.cdrom
        only Linux
        type = dd_test
        images += " stg1"
        create_image_stg1 = yes
        image_name_stg1 = stg1
        image_size_stg1 = 1M
        image_snapshot_stg1 = no
        drive_index_stg1 = 3
        dd_count = 1
        # last input and output disk
        dd_if_select = -1
        dd_of_select = -1
        variants:
            - readwrite:
                dd_stat = 0
                variants:
                    - zero2disk:
                        dd_if = ZERO
                        dd_of = /dev/[shv]d?
                    - disk2null:
                        dd_if = /dev/[shv]d?
                        dd_of = NULL
            - readonly:
                # ide, ahci don't support readonly disks
                no ide, ahci
                image_readonly_stg1 = yes
                variants:
                    - zero2disk:
                        dd_if = ZERO
                        dd_of = /dev/[shv]d?
                        dd_stat = 1
                    - disk2null:
                        dd_if = /dev/[shv]d?
                        dd_of = NULL
                        dd_stat = 0

    - migrate:
        type = migration
        migration_test_command = help
        migration_bg_command = "cd /tmp; nohup ping localhost"
        migration_bg_check_command = pgrep ping
        migration_bg_kill_command = pkill ping
        kill_vm_on_error = yes
        iterations = 2
        max_vms = 2
        used_mem = 1024
        mig_timeout = 3600
        monitor_type = human
        monitors = humanmonitor1
        main_monitor = humanmonitor1
        # you can uncomment the following line to enable the state
        # check
        # vmstate_check = yes
        variants:
            - tcp:
                migration_protocol = "tcp"
            - unix:
                no HOST_RHEL.5
                migration_protocol = "unix"
            - exec:
                migration_protocol = "exec"
                migration_exec_cmd = "gzip"
            - mig_cancel:
                migration_protocol = "tcp"
                mig_cancel = True
        variants:
            - @default:
            - with_blkdebug:
                drive_blkdebug_image1 = blkdebug/default.conf
                drive_rerror_image1 = stop
                drive_werror_image1 = stop
                vmstate_check = yes
                migration_living_guest = no
            - with_set_speed:
                mig_speed = 1G
                pre_migrate = "mig_set_speed"
            - with_reboot:
                iterations = 1
                type = migration_with_reboot
            - with_file_transfer:
                # down time of migrate.exec is too big for file_transfer
                no exec
                iterations = 1
                type = migration_with_file_transfer
            - with_netperf:
                only Linux
                iterations = 1
                type = migration_with_netperf
                client_num = 100
                netperf_timeout = 1000
                mig_timeout = 1000
                netperf_path = ../netperf2
                setup_cmd = tar xfj netperf-2.4.5.tar.bz2 && cd netperf-2.4.5 && patch -p0 < ../wait_before_data.patch && ./configure && make
                netperf_cmd = netperf-2.4.5/src/netperf -H %s -l %s
                netserver_cmd =  %s/netperf2/netperf-2.4.5/src/netserver
            - with_stress:
                only Linux
                iterations = 1
                variants:
                    - io_stress:
                        test_timeout = 4200
                        ping_pong = 10
                        guest_stress_test = "autotest"
                        test_type = "iozone"
                        stress_stop_cmd = "killall autotest"
                    - mem_stress:
                        ping_pong = 10
                        test_timeout = 600
                        guest_stress_test = "autotest"
                        test_type = "stress_memory_heavy"
            - between_vhost_novhost:
                only Host_RHEL.6
                no Host_RHEL.6.1
                migrate_between_vhost_novhost = "yes"
                type = migration_with_file_transfer

    - migrate_multi_host: install setup image_copy unattended_install.cdrom
        type = migration_multi_host
        vms = "vm1"
        start_vm = no
        migration_test_command = help
        migration_bg_command = "cd /tmp; nohup tcpdump -q -i any -t ip host localhost"
        migration_bg_check_command = pgrep tcpdump
        migration_bg_kill_command = pkill tcpdump
        kill_vm_on_error = yes
        iterations = 2
        used_mem = 1024
        mig_timeout = 4800
        disk_prepare_timeout = 360
        comm_port = 13234
        regain_ip_cmd = killall dhclient; sleep 10; dhclient;
        variants:
            #Migration protocol.
            -tcp:
                type = migration_multi_host
            -fd:
                type = migration_multi_host_fd

    - migration_multi_host_with_file_transfer: install setup image_copy unattended_install.cdrom
        type = migration_multi_host_with_file_transfer
        vms = "vm1"
        start_vm = no
        kill_vm_on_error = yes
        used_mem = 1024
        mig_timeout = 4800
        disk_prepare_timeout = 360
        comm_port = 13234
        #path where file is stored on guest.
        guest_path = "/tmp/file"
        #size of generated file.
        file_size = 500
        transfer_timeout = 240
        #Transfer speed in Mb
        transfer_speed = 100
        #Count of migration during file transfer.
        migrate_count = 3

    - boot_savevm:
        no raw
        no raw_dd
        type = boot_savevm
        savevm_delay = 0.3
        savevm_login_delay = 120
        savevm_timeout = 2000
        kill_vm_on_error = yes
        kill_vm_gracefully = yes
        kill_vm = yes

    - save_restore: install setup image_copy boot
        type = save_restore
        # Number of times to repeat save/restore
        save_restore_repeat = 1
        # Seconds to allow for guest runtime
        save_restore_start_delay = 4.0
        # Seconds to wait before restoring guest
        save_restore_delay = 1.0
        # Maximum time test allowed to run
        save_restore_duration = 60.0
        # Guest command to run, e.g.: Keep one CPU busy and memory dirty.
        # Note: Command will be backgrounded by appending a '&'
        save_restore_bg_command = '( mkdir -p /x && mount -t tmpfs -o size=75% x /x && while true; do dd if=/dev/urandom of=/x/x; done; umount /x && rmdir /x )'
        save_restore_path = "/tmp"
        kill_unresponsive_vms = no
        restart_vm = no
        kill_vm = yes
        variants:
            # Tests assumed to include install and boot before,
            # and a shutdown after the lifecycle test
            - lifecycle_short: unattended_install.cdrom boot
                save_restore_repeat = 25
                save_restore_duration = 1200.0
            - lifecycle_medium: unattended_install.cdrom boot
                save_restore_repeat = 50
                save_restore_delay = 1.0
                save_restore_duration = 2600.0
            - lifecycle_long: unattended_install.cdrom boot
                save_restore_repeat = 100
                save_restore_duration = 5400.0


    - autotest:
        only Linux
        type = autotest
        test_timeout = 720
        test_control_file = control
        variants:
            - sleeptest:
                test_name = sleeptest
                test_timeout = 30
                test_control_file = sleeptest.control
            - dbench:
                test_name = dbench
                test_control_file = dbench.control
                profilers += "iostat sar "
            - bonnie:
                test_name = bonnie
                test_control_file = bonnie.control
                test_timeout = 9000
            - ebizzy:
                test_name = ebizzy
                test_control_file = ebizzy.control
            - stress:
                test_name = stress
                test_control_file = stress.control
            - disktest:
                test_name = disktest
                test_control_file = disktest.control
            - ctcs2:
                test_name = cerberus
                test_control_file = cerberus.control
            - npb:
                test_name = npb
                test_control_file = npb.control
                smp = 2
            - linus_stress:
                test_name = linus_stress
                test_control_file = linus_stress.control
            - monotonic_time:
                no Host_RHEL.5
                no RHEL.3.9
                test_timeout = 1500
                test_name = monotonic_time
                test_control_file = monotonic_time.control
                required_cpu_flags = "constant_tsc"
                pre_command = "/usr/bin/python scripts/check_cpu_flag.py"
            - tsc:
                no RHEL.3.9
                test_name = tsc
                test_control_file = tsc.control
                required_cpu_flags = "constant_tsc"
                pre_command = "/usr/bin/python scripts/check_cpu_flag.py"
            - cpu_hotplug:
                no RHEL.3.9
                no RHEL.4
                test_name = cpu_hotplug
                test_control_file = cpu_hotplug.control
                kill_vm = yes
            - ltp:
                only RHEL.6
                test_timeout = 1000000
                test_name = ltp
                test_control_file = ltp.control
            - ltp_ballista:
                only RHEL.6
                test_timeout = 1000000
                test_name = ltp_ballista
                test_control_file = ltp.control.ballista
            - signaltest:
                test_name = signaltest
                test_control_file = signaltest.control
            - libhugetlbfs:
                no RHEL.3.9
                no RHEL.4
                setup_hugepages = yes
                extra_params += " -mem-path /mnt/kvm_hugepage"
                test_name = libhugetlbfs
                test_control_file = libhugetlbfs.control
            - parallel_dd:
                test_name = parallel_dd
                test_timeout = 36000
                images += " stg"
                image_format_stg = qcow2
                boot_drive_stg = yes
                image_name_stg = storage
                image_size_stg = 10G
                force_create_image_stg = yes
                test_control_file = parallel_dd.control
            - iozone:
                test_name = iozone
                test_timeout = 4200
                test_control_file = iozone.control
                profilers += "sar iostat "
                mem = 2048
                variants:
                    aio_native:
                        image_aio = native
                    aio_threads:
                        image_aio = threads
            - iasl:
                only RHEL.5
                test_name = iasl
                test_control_file = iasl.control
            - scrashme:
                test_name = scrashme
                test_control_file = scrashme.control
                test_timeout = 56000
            - scrashme.fast:
                test_name = scrashme
                test_control_file = scrashme.fast.control
            - hwclock:
                test_name = hwclock
                test_control_file = hwclock.control
            - enable_serial_console:
                test_name = enable_serial
                test_control_file = enable_serial.control
                kill_vm = yes
            - aiostress:
                test_name = aiostress
                test_control_file = aiostress.control
            - compliebench:
                test_name = compilebech
                test_control_file = compilebench.control
            - dacapo:
                test_name = dacapo
                test_control_file = dacapo.control
            - dma_memtest:
                test_name = dma_memtest
                test_control_file = dma_memtest.control
            - fsfuzzer:
                test_name = fsfuzzer
                test_control_file = fsfuzzer.control
            - fsstress:
                test_name = fsstress
                test_control_file = fsstress.control
                test_timeout = 36000
            - hackbench:
                test_name = hackbench
                test_control_file = hackbench.control
            - interbench:
                test_name = interbench
                test_control_file = interbench.control
            - kernbench:
                test_name = kernbench
                test_control_file = kernbench.control
            - lmbench:
                test_name = lmbench
                test_control_file = lmbench.control
            - pktgen:
                no RHEL.3.9
                no RHEL.4
                test_name = pktgen
                test_control_file = pktgen.control
            - posixtest:
                test_timeout = 7200
                test_name = posixtest
                test_control_file = posixtest.control
            - rmaptest:
                test_name = rmaptest
                test_control_file = rmaptest.control
            - signaltest:
                test_name = signaltest
                test_control_file = signaltest.control
            - synctest:
                test_name = synctest
                test_control_file = synctest.control
            - tbench:
                test_name = tbench
                test_control_file = tbench.control
            - tiobench:
                test_name = tiobench
                test_control_file = tiobench.control
            - unixbench:
                test_name = unixbench
                test_timeout = 7200
                test_control_file = unixbench.control
            - perfmon:
                only RHEL.6
                test_name = perfmon
                test_control_file = perfmon.control
            - rtc:
                no Host_RHEL.5
                test_name = rtc
                test_timeout = 180
                test_control_file = rtc.control
            - phoronix:
                test_name = phoronix
                test_control_file = phoronix.control
                test_timeout = 7200
            - ffsb:
                test_name = ffsb
                test_control_file = ffsb.control
            - rhts_linpack:
                no single_vcpu
                test_name = rhts_linpack
                test_control_file = rhts_linpack.control
                test_timeout = 7200
            - linpack:
                test_name = linpack
                test_control_file = linpack.control
            - systemtap:
                test_name = systemtap
                test_control_file =systemtap.control
            - cpuflags-stress:
                test_control_file = cpuflags.control

    - qemu_img_commit:  install setup image_copy unattended_install.cdrom
        type = qemu_img
        subcommand = commit

    - stop_continue:
        type = stop_continue
        kill_vm_on_error = yes

    - nfs_corrupt:
        only Linux
        type = nfs_corrupt
        start_vm = no
        images += " stg"
        image_size_stg = "10G"
        image_format_stg = "qcow2"
        create_image_stg = no
        force_create_image_stg = no
        remove_image_stg = yes
        drive_werror = stop
        drive_cache = none
        kill_vm = yes
        post_command_noncritical = yes
        wait_paused_timeout = 120
        nfs_stat_chk_re = "running"
        RHEL.6:
            nfs_devname = /dev/sdb

    - guest_s3:
        no RHEL.3.9
        no RHEL.4
        type = guest_s3
        kill_vm_on_error = yes

    - timedrift:
        rtc_clock = "host"
        rtc_drift = "slew"
        drift_threshold = 10
        drift_threshold_single = 3
        variants:
            - with_load:
                type = timedrift
                # Pin the VM and host load to CPU #0
                cpu_mask = 0x1
                # Set the load and rest durations
                load_duration = 20
                rest_duration = 20
                # Fail if the drift after load is higher than 50%
                drift_threshold = 50
                # Fail if the drift after the rest period is higher than 10%
                drift_threshold_after_rest = 10
                # For now, make sure this test is executed alone
                used_cpus = 100
                test_duration = 600
                interval_gettime = 120
                variants:
                    - @default:
                    - full_load:
                        test_duration = 28800
                        interval_gettime = 1800
                        pre_command = touch /tmp/host_load_timedrift; for (( I=0; I<`grep -c 'processor' /proc/cpuinfo`; I++ )); do echo $I;taskset -c $I /bin/bash -c 'while [ -e /tmp/host_load_timedrift ]; do :; done&'; done
                        post_command = rm -f /tmp/host_load_timedrift
            - with_migration:
                type = timedrift_with_migration
                migration_iterations = 3
            - with_reboot:
                type = timedrift_with_reboot
                reboot_iterations = 1
            - with_stop:
                no RHEL.3.9
                no RHEL.4
                type = timedrift_with_stop
                stop_interations = 1
            - with_signal_stop:
                no RHEL.3.9
                no RHEL.4
                type = timedrift_with_stop
                stop_interations = 1
                stop_with_signal = yes
            - monotonicity:
                type = timedrift_monotonicity
                cmd_get_time = "date +%s%N"
                time_linger = 60
                host_path = "/tmp/timedrift-monotonicity-result.txt"
                cmd_timeout = 100
                kill_vm_on_error = yes
                # can use this cmd to load host in timedrift testing
                # pre_command = for(( I=0; I<`cat /proc/cpuinfo | grep processor | wc -l`;I++)) ;do echo $I; taskset -c $I /bin/bash -c 'for ((;;)); do X=1;done &'; done
                variants:
                    - @default:
                    - long:
                        time_linger = 1800
            - with_savevm:
                no raw
                no raw_dd
                type = timedrift_with_savevm
                #keep this value is empty as use max_drift_threshold to judgement drift now
                drift_threshold =
                max_drift_threshold = 10
                sleep_time = 300
                times_gettime = 3
                interval_gettime = 600
        variants:
            - @default:
                no RHEL.5
            - with_pvclock:
                boot_option_added = "divider=10"
                only RHEL.5
            - without_pvclock:
                cpu_model_flags += ",-kvmclock"
                only RHEL.5

    - balloon_check:
        no Host_RHEL.5
        only Linux
        no RHEL.3.9
        no RHEL.4.9
        kill_vm_on_error = yes
        variants:
            - @enable:
                type = balloon_check
                extra_params += " -balloon virtio"
                variants:
                    - base:

                    - balloon-migrate:
                        sub_balloon_test_enlarge = "migration"
                        sub_balloon_test_evict = "migration"
                    - balloon-guest_s3:
                        sub_balloon_test_enlarge = "guest_s3"
                        sub_balloon_test_evict = "guest_s3"
                    - balloon-reboot:
                        sub_balloon_test_enlarge = "boot"
                        sub_balloon_test_evict = "boot"
                        reboot_method = shell
                        kill_vm_on_error = yes
                        reboot = yes
                    - balloon-guest_s4:
                        sub_balloon_test_enlarge = "guest_s4"
                        sub_balloon_test_evict = "guest_s4"
                    - balloon-shutdown_enlarge:
                        sub_balloon_test_enlarge = "shutdown"
                        shutdown_method = shell
                        kill_vm = yes
                        kill_vm_gracefully = no
                        check_img = yes
                    - balloon-shutdown_evict:
                        shutdown_method = shell
                        kill_vm = yes
                        kill_vm_gracefully = no
                        sub_balloon_test_evict = "shutdown"

            - disable:
                type = balloon_disable
                extra_params += " -balloon none"

            - check_qmp:
                only RHEL.6
                image_snapshot = yes
                extra_params += " -balloon virtio"
                type = kernel_install
                install_type = tar
                kernel_patch_list = ""
                kerne_src_pkg = http://fileshare.englab.nay.redhat.com/pub/section2/kvm/pub/test_src/linux-2.6.34.tar.bz2
                kernel_config = http://fileshare.englab.nay.redhat.com/pub/section2/kvm/pub/test_src/config-64
                kernel_tag = 2.6.34
                test_timeout_install = 7200
                sub_test = qmp_command
                pre_command_run += "/usr/libexec/qemu-kvm --help|grep '\-qmp' || echo 'Qemu-kvm does not support qmp!';"
                monitors = ' humanmonitor1 qmp1 qmp2'
                monitor_type_qmp1 = qmp
                monitor_type_qmp2 = qmp
                monitor_type = human
                main_monitor = humanmonitor1
                event_cmd_type = monitor_cmd
                qmp_cmd_run = "query-balloon"
                cmd_return_parttern_run = r"{"return": {"actual": /d+, "mem_swapped_in": /d+, "minor_page_faults":/d+, "mem_swapped_out": /d+, "free_mem": /d+, "major_page_faults":/d+, "total_mem": /d+}}"
                post_cmd = "info balloon"
                cmd_result_check = m_format_q

    - watchdog: install setup image_copy unattended_install.cdrom
        only RHEL.5, RHEL.6
        type = watchdog
        extra_params += " -watchdog i6300esb -watchdog-action reset"
        relogin_timeout = 240

    - smbios_table: install setup image_copy unattended_install.cdrom
        only Linux
        type = smbios_table

    - softlockup: install setup unattended_install.cdrom
        only Linux
        type = softlockup
        softlockup_files = stress-1.0.4.tar.gz
        stress_setup_cmd = "cd %s && tar xvf stress-1.0.4.tar.gz && cd stress-1.0.4 && ./configure && make && cd src"
        server_setup_cmd = "%s/heartbeat_slu.py --server --threshold %s --file %s --port %s --verbose --check-drift"
        client_setup_cmd = "%s/heartbeat_slu.py --client --address %s --file %s --port %s --interval 1"
        stress_cmd  = "cd %s && cd stress-1.0.4 && cd src && nohup ./stress -c %s > /dev/null 2>&1&"
        kill_monitor_cmd = "ps aux | grep heart | grep -v grep | awk '{print$2}' | xargs kill -9 > /dev/null 2>&1"
        kill_stress_cmd = "pkill -f stress > /dev/null 2>&1"
        drift_cmd = "tail -1 %s | awk '{print $7}'"
        monitor_log_file_server = /tmp/heartbeat_server.log
        monitor_log_file_client = /tmp/heartbeat_client.log
        monitor_port = 13330
        stress_threshold = 10
        # time_to_run (hours) = 12, 18, 24, 48 hours
        test_length = 0.10


    - stress_boot:
        type = stress_boot
        max_vms = 5
        alive_test_cmd = uname -a
        kill_vm = yes
        kill_vm_vm1 = no
        kill_vm_gracefully = no
        image_snapshot = yes
        bridge = vbr0
        nic_script = scripts/qemu-ifup-vbr0
        pre_command += "scripts/private_br.sh notftp;"
        post_command = "scripts/private_br.sh;"

    - guest_test:
        type = guest_test
        login_timeout = 360
        test_timeout = 600
        dst_rsc_dir = "/tmp"
        download = no
        remote_copy = yes
        script_params =
        variants:
            - stub:
                test_name = "stub"
                interpreter = "python"
                rsc_path = "tests_rsc/stub.py"
            - stub_d:
                test_name = "stub_d"
                interpreter = "python"
                rsc_path = "tests_rsc/stub"
                rsc_entry = "index.py"
            - arp_set:
                no RHEL.3.9
                test_name = "arp_set"
                interpreter = "python"
                rsc_path = "tests_rsc/arp_set.py"
            - autoit:
                only Windows
                test_name = "autoit"
                test_timeout = 1800
                interpreter = "cmd /c D:\\AutoIt3.exe"
                download = yes
                remote_copy = no
                download_cmd = "git clone"
                rsc_server = "git://qe-git.englab.nay.redhat.com/s2/autoit"
                dst_rsc_dir = "C:\"
                reboot = yes
                variants:
                    - notepad:
                        guest_script = autoit/notepad1.au3
                        download = no
                        dst_rsc_path = "C:\notepad.au3"
                    - stub:
                        test_name += "stub"
                        rsc_server = "git://qe-git.englab.nay.redhat.com/s2/stub"
                        interpreter = "cmd /c echo test"
                        dst_rsc_path = ""
                    - super_pi:
                        test_name += "super_pi"
                        dst_rsc_path = "C:\autoit\super_pi\run_super_pi.au3"
                    - disk_dfrg:
                        no 64
                        test_name += "disk_dfrg"
                        dst_rsc_path = "C:\autoit\DiskDefragment\difrag.au3"
                    - cpu_bench:
                        test_name += "cpu_bench"
                        dst_rsc_path = "C:\autoit\CpuBench\7zipbench.au3"
                    - web_bench:
                        test_name += "web_bench"
                        variants:
                            - wb_install:
                                test_name += "install"
                                dst_rsc_path = "C:\autoit\webBench\install_webBench.au3"
                            - run: guest_test.autoit.web_bench.wb_install
                                test_name += "run"
                                interpreter = "cmd /c "
                                dst_rsc_path = "C:\autoit\webBench\runBench.bat"
                    - intel_burn_test:
                        test_name = "IntelBurnTest"
                        mem = 2048
                        dst_rsc_path = "C:\autoit\IntelBurnTest\run_IntelBurnTest.au3"

                    - sandra:
                        no Win7
                        no Win2008
                        no Win2008r2
                        test_name += "sandra"
                        variants:
                            - sandra_install:
                                test_name += "install"
                                dst_rsc_path = "C:\autoit\sandra\install_sandra.au3"
                            - run: guest_test.autoit.sandra.sandra_install
                                test_name += "run"
                                dst_rsc_path = "C:\autoit\sandra\run_sandra.au3"
            - powershell:
                interpreter = "cmd /c powershell.exe -File"
                variants:
                    - stub:
                        download = yes
                        download_cmd = "git clone"
                        rsc_server = "git://the.resource.server/powershell"
                        dst_rsc_dir = "C:\"
                        dst_rsc_path = "C:\powershell\stub\stub.ps1"

    - iozone_windows:
        only Windows
        type = iozone_windows
        variants:
            aio_native:
                image_aio = native
            aio_threads:
                image_aio = threads

    - whql:
        only Windows
        no Win2008
        nic_mode = tap
        # Replace this with the address of an installed DTM server
        server_address = 10.66.91.35
        # The server should run rss.exe like a regular Windows VM, preferably
        # with administrator privileges (or at least with permission to write
        # to the DTM studio directory)
        server_shell_port = 10022
        server_file_transfer_port = 10023
        server_studio_path = %programfiles%\Microsoft Driver Test Manager\Studio
        wtt_services = wttsvc
        variants:
            - support_vm_install:
                # The support VM is identical to the tested VM in every way
                # except for the image name which ends with '-supportvm'.
                type = unattended_install
                image_name += -supportvm
                extra_params += " -boot d"
                force_create_image = yes
                kill_vm = yes
                nic_mode = user
                redirs += " unattended_install"
                guest_port_unattended_install = 12323
                medium = cdrom
                kernel =
                initrd =
            - client_install:    support_vm_install
                type = whql_client_install
                dsso_delete_machine_binary = deps/whql_delete_machine_15.exe
                # The username and password are required for accessing the DTM client
                # installer binary shared by the server
                server_username = administrator
                server_password = 1q2w3eP
                # This path refers to a shared directory on the server
                # (the final cmd will be something like \\servername\DTMInstall\...)
                whql_install_cmd = \DTMInstall\Client\Setup.exe /passive
                whql_install_timeout = 3600
            - submission:    client_install support_vm_install
                type = whql_submission
                extra_params += " -snapshot"
                dsso_test_binary = deps/whql_submission_15.exe
                test_timeout = 3600
                device_data = cat0 cat1 cat2 cat3 logoarch logoos whqlos whqlqual prog desc filter virt
                descriptors = desc1 desc2 desc3
                # DeviceData names
                dd_name_cat0     = Category
                dd_name_cat1     = Category
                dd_name_cat2     = Category
                dd_name_cat3     = Category
                dd_name_logoarch = LogoProcessorArchitecture
                dd_name_logoos   = LogoOperatingSystem
                dd_name_whqlos   = WhqlOs
                dd_name_whqlqual = WhqlQualification
                dd_name_prog     = LogoProgramId
                dd_name_desc     = LogoProgramDescription
                dd_name_filter   = WDKFilterAttribute
                dd_name_virt     = ParaVirtualizationDriver
                # Common DeviceData data
                dd_data_filter   = FilterIfNoInf
                dd_data_virt     = True
                variants:
                    - keyboard:
                        # test_device is a regular expression that should match a device's
                        # name as it appears in device manager.  The first device that matches
                        # is used.
                        test_device = keyboard
                        # Set timeout to 10 hours
                        test_timeout = 36000
                        dd_data_cat0 = Input\Keyboard
                        dd_data_cat1 = Device Fundamentals
                        dd_data_cat2 = System Fundamentals\Dynamic Partitioning
                        dd_data_prog = InputKbd
                        dd_data_desc = Input > Keyboard
                    - hdd:
                        test_device = qemu harddisk
                        device_data += " ex0 ex1 ex2 ex3"
                        dd_data_cat0 = Storage\Device Class\Disk\Disk
                        dd_data_cat1 = Storage\Device Class\Disk\Fixed
                        dd_data_cat2 = Storage\Device Class\Disk\Bus\ATA
                        dd_data_cat3 = Device Fundamentals
                        dd_data_prog = StorHDD
                        dd_data_desc = Storage > Hard Disk Drive (HDD)
                        dd_name_ex0 = Storage_bus_type
                        dd_data_ex0 = ATA/ATAPI
                        dd_name_ex1 = Hybrid_HDD_Support
                        dd_data_ex1 = 0
                        dd_name_ex2 = Non_Rotating_Media
                        dd_data_ex2 = 0
                        dd_name_ex3 = Secure_Storage
                        dd_data_ex3 = 0
                        variants:
                            - full:
                                # Yes, 100 hours, this is not a mistake
                                test_timeout = 360000
                            - syscache_test:
                                job_filter = syscache test
                                test_timeout = 7200
            - whql_env_setup:
                vms = ""
                type = whql_env_setup
                smp = 4
                rtc_drift = "slew"
                drive_werror = stop
                drive_rerror = stop
                family = "0xf"
                uuid = random
                cdrom_whql = images/winXP/whql.iso
                force_create_image = yes
                force_create_image_image1 = no
                update_cmd = cmd /c E:\wua_update.exe && cmd /c net stop wuauserv && cmd /c net start wuauserv && cmd /c D:\whql\WUInstall.exe /install /criteria "IsHidden=0 and IsInstalled=0 and IsAssigned=1" 
                auto_restart = "cmd /c regedit /s D:\whql\auto_restart_disable.reg"
                disable_uas =  "cmd /c regedit /s D:\whql\UAC_disable.reg"
                dbgview_cmd = "cmd /c E:\dbgview_install.exe"
                setup_timeout = 9000
                disable_firewall = "netsh firewall set opmode mode=disable"
                disable_update = "net stop wuauserv"
                timezone_cmd = "tzutil /s "China Standard Time""
                src_list = "http://fileshare.englab.nay.redhat.com/pub/section2/kvm/pub/whql/dbg_tools/dbg_x86_6.11.1.404.msi"
                src_list += ",http://fileshare.englab.nay.redhat.com/pub/section2/kvm/pub/whql/DebugView/Dbgview.exe"
                src_list += ",http://fileshare.englab.nay.redhat.com/pub/section2/kvm/pub/whql/misc_tools/UAC_disable.reg"
                src_list += ",http://fileshare.englab.nay.redhat.com/pub/section2/kvm/pub/whql/misc_tools/WUInstall.exe"
                src_list += ",http://fileshare.englab.nay.redhat.com/pub/section2/kvm/pub/whql/misc_tools/auto_restart_disable.reg"
                src_list += ",http://fileshare.englab.nay.redhat.com/pub/section2/kvm/pub/whql/misc_tools/dbgview_install.exe"
                src_list += ",http://fileshare.englab.nay.redhat.com/pub/section2/kvm/pub/whql/misc_tools/whql_nic_set.exe"
                src_list += ",http://fileshare.englab.nay.redhat.com/pub/section2/kvm/pub/whql/misc_tools/WindowsUpdateAgent30-x86.exe"
                src_list += ",http://fileshare.englab.nay.redhat.com/pub/section2/kvm/pub/whql/misc_tools/wua_update.exe"
                src_list += ",http://fileshare.englab.nay.redhat.com/pub/section2/kvm/pub/whql/dbg_tools/dbg_install.bat"
                src_list += ",http://fileshare.englab.nay.redhat.com/pub/section2/kvm/pub/whql/dbg_tools/dbg_x86_6.11.1.404.msi"
                src_list += ",http://fileshare.englab.nay.redhat.com/pub/section2/kvm/pub/whql/misc_tools/disk_driver_check.exe"
                variants:
                    - nic_device:
                        nics += ' nic2 nic3'
                        nic_model = virtio
                        nic_model_nic1 = rtl8139
                        nic_config_cmd = "cmd /c D:\whql\whql_nic_set.exe"

                    - block_device:
                        image_snapshot = yes
                        images += " stg stg2 stg3 stg4"
                        image_format_stg = raw
                        image_name_stg = storage
                        image_size_stg = 2G
                        image_format_stg2 = raw
                        image_name_stg2 = storage2
                        image_size_stg2 = 2G
                        image_format_stg3 = raw
                        image_name_stg3 = storage3
                        image_size_stg3 = 2G
                        image_format_stg4 = raw
                        image_name_stg4 = storage4
                        image_size_stg4 = 2G
                        win_format_stg = NTFS
                        win_format_stg2 = NTFS
                        win_format_stg3 = FAT
                        win_format_stg4 = FAT32
                        win_extra_stg = "/c"
                        #symbol_files git repo not set up yet will update this inside
                        #different guest config later
                        symbol_files = "git://qe-git.englab.nay.redhat.com/whql/winxp"
                        debuggers_install = "cmd  /c E:\dbg_install.bat"
                        symbol_file_download = "cmd /c C:\debuggers\symchk /r C:\windows\system32 /s SRV*C:\symbols\*http://msdl.microsoft.com/download/symbols & dir"
                        symbol_file_check = "cmd /c C:\debuggers\symchk C:\windows\system32\ntoskrnl.exe /s C:\symbols\"
                        symbol_check_pattern = "SYMCHK: FAILED files = 0"
                        symbol_pid_pattern = "symchk.*?PID:\s+(\d+)"

                        disk_driver_install = "cmd /c E:\disk_driver_check.exe "
                        format_cmd = "format %s: /FS:%s /V:local /y"
                        disk_init_cmd = "echo select disk %s > cmd && echo create partition primary  >> cmd && echo select partition 1 >> cmd && echo assign letter=%s >> cmd && echo exit >> cmd && diskpart /s cmd"

    - win_virtio_update:
        type = win_virtio_update
        vms = ""
        drivers_install = "balloon;block;nic"
        mount_point = "/tmp/mnt"
        driver_install_cmd_balloon = cmd /c E:\\whql\virtio_driver_install_whql.exe F:\\Balloon\\xp\\x86 balloon
        driver_install_cmd_block = cmd /c  E:\\whql\virtio_driver_install_whql.exe F:\\viostor\\xp\\x86 block
        driver_install_cmd_nic = cmd /c E:\\whql\virtio_driver_install_whql.exe F:\\\NetKVM\\xp\\x86 nic
        check_str_balloon = Virtio Balloon
        check_str_block = Virtio SCSI DISK
        check_str_nic = VirtIO Ethernet Adapter
        check_cmd = wmic sysdriver get caption
        check_cmd_block = wmic diskdrive get caption
        check_cmd_nic = wmic nic get caption

        extra_params += " -balloon virtio"
        images += " stg"
        image_name_stg = "storage"
        image_size_stg = 1G
        drive_format_stg = virtio
        force_create_image_stg = yes
        nics += " nic2"
        nic_model_nic2 = virtio
        cdroms += " virtio"
        cdrom_virtio = isos/windows/virtio-win.iso


    - guest_s4:
        no RHEL.3
        no virtio_blk
        no virtio_nic
        #kill_vm = yes
        type = guest_s4
        kill_vm_on_error = yes

    - nic_hotplug:
        no RHEL.3.9
        pci_type = nic
        type = pci_hotplug
        reference_cmd = lspci
        find_pci_cmd = 'lspci | tail -n1'
        pci_test_cmd = 'echo %s; nslookup www.redhat.com'
        wait_secs_for_hook_up = 3
        variants:
            - nic_8139:
                no Win2008
                pci_model = rtl8139
                match_string = "8139"
            - nic_virtio:
                only virtio_nic virtio_blk
                pci_model = virtio-net-pci
                match_string = "Virtio network device"
            - nic_e1000:
                no Windows
                pci_model = e1000
                match_string = "Gigabit Ethernet Controller"
        variants:
            - one_pci:
                pci_num = 1
                repeat_times = 1
            - multi_pci:
                pci_num = 2
                repeat_times = 1
            - additional:
                no Host_RHEL.5
                type = nic_hotplug
            - migration:
                no Host_RHEL.5
                type = migration_after_nichotplug
                kill_vm = yes
                monitor_type = human
                monitors = humanmonitor1
                main_monitor = humanmonitor1
                nic_model = virtio

    - block_hotplug:
        no RHEL.3.9
        type = pci_hotplug
        # We don't support SCSI drive_format now
        no block_scsi
        pci_type = block
        reference_cmd = lspci
        find_pci_cmd = 'lspci | tail -n1'
        images += " stg0"
        boot_drive_stg0 = no
        boot_drive_stg1 = no
        image_name_stg0 = storage0
        image_name_stg1 = storage1
        image_size_stg0 = 1G
        image_size_stg1 = 1G
        remove_image_stg0 = yes
        remove_image_stg1 = yes
        force_create_image_stg0 = yes
        force_create_image_stg1 = yes
        pci_test_cmd = "echo %s; yes | mke2fs `fdisk -l 2>&1 | awk '/\/dev\/[sv]d[a-z]* doesn/ {print $2}'` | sort | tail -1"
        wait_secs_for_hook_up = 3
        kill_vm_on_error = yes
        variants:
            - block_virtio:
                only virtio_nic virtio_blk
                pci_model = virtio
                match_string = "Virtio block device"
            - block_scsi:
                no Linux
                no Windows
                pci_model = scsi
                match_string = "SCSI"
        variants:
            - fmt_qcow2:
                image_format_stg = qcow2
                image_format_stg0 = qcow2
                image_format_stg1 = qcow2
                image_format_stg2 = qcow2
                image_format_stg3 = qcow2
                image_format_stg4 = qcow2
                image_format_stg5 = qcow2
                image_format_stg6 = qcow2
                image_format_stg7 = qcow2
                image_format_stg8 = qcow2
                image_format_stg9 = qcow2
                image_format_stg10 = qcow2
                image_format_stg11 = qcow2
                image_format_stg12 = qcow2
                image_format_stg13 = qcow2
                image_format_stg14 = qcow2
                image_format_stg15 = qcow2
                image_format_stg16 = qcow2
                image_format_stg17 = qcow2
                image_format_stg18 = qcow2
                image_format_stg19 = qcow2
                image_format_stg20 = qcow2
                image_format_stg21= qcow2
                image_format_stg22= qcow2
                image_format_stg23= qcow2
                image_format_stg24= qcow2
                image_format_stg25= qcow2
                image_format_stg26= qcow2
                image_format_stg27= qcow2
            - fmt_raw:
                image_format_stg = raw
                image_format_stg0 = raw
                image_format_stg1 = raw
        variants:
            - one_pci:
                pci_num = 1
                repeat_times = 300
            - multi_pci:
                pci_num = 2
                repeat_times = 2
                images += " stg1"
            - check_pci:
                type= pci_hotplug_check
                guest_check_cmd = cat /proc/partitions
                mark_cmd = "echo "%s"| dd of=/dev/%s count=1 bs=%s seek=1"
                confirm_cmd = "dd if=/dev/%s bs=%s count=1 skip=1"
                offset = 64k
                repeat_times = 256000
                pci_num = 27
                images += " stg1 stg2 stg3 stg4 stg5 stg6 stg7 stg8 stg9 stg10 stg11 stg12 stg13 stg14 stg15 stg16 stg17 stg18 stg19 stg20 stg21 stg22 stg23 stg24 stg25 stg26"
                boot_drive = no
                boot_drive_image1 = yes
                image_name_stg0 = storage0
                image_name_stg1 = storage1
                image_name_stg2 = storage2
                image_name_stg3 = storage3
                image_name_stg4 = storage4
                image_name_stg5 = storage5
                image_name_stg6 = storage6
                image_name_stg7 = storage7
                image_name_stg8 = storage8
                image_name_stg9 = storage9
                image_name_stg10 = storage10
                image_name_stg11 = storage11
                image_name_stg12 = storage12
                image_name_stg13 = storage13
                image_name_stg14 = storage14
                image_name_stg15 = storage15
                image_name_stg16 = storage16
                image_name_stg17 = storage17
                image_name_stg18 = storage18
                image_name_stg19 = storage19
                image_name_stg20 = storage20
                image_name_stg21 = storage21
                image_name_stg22 = storage22
                image_name_stg23 = storage23
                image_name_stg24 = storage24
                image_name_stg25 = storage25
                image_name_stg26 = storage26
                image_name_stg27 = storage27
                image_size = 128k
                remove_image = yes
                remove_image_image1 = no
                force_create_image = yes
                force_create_image_image1 = no

    - enospc:
        only Linux
        type = enospc
        start_vm = no
        images += " stg"
        drive_werror = stop
        drive_cache = none
        image_name_stg = enospc
        image_format_stg = qcow2
        image_snapshot_stg = no
        check_image_stg = no
        background_cmd = "nohup dd if=/dev/zero of=%s bs=1024 &"
        vgtest_name = vg_kvm_test_enospc
        lvtest_name = lv_kvm_test_enospc
        kill_vm = yes

    - qmp_basic:
        no Host_RHEL.5
        type = qmp_basic
        pre_command += "/usr/libexec/qemu-kvm --help|grep '\-qmp' || echo 'Qemu-kvm does not support qmp!';"
        monitors += ' qmp'
        monitor_type_qmp = qmp

    - vlan:
        only Linux
        no RHEL.3.9
        type = vlan
        # subnet should not be used by host
        subnet = "192.168"
        vlan_num = 5
        file_size = 10
        maximal = 4094
        listen_cmd = "nc -l %s > %s"
        send_cmd = "nc %s %s < %s"
        nic_mode = tap
        vms += " vm2"
        image_snapshot = yes
        kill_vm_vm2 = yes
        kill_vm_gracefully_vm2 = no
        RHEL.4:
            listen_cmd = "nc -l -p %s > %s"

    - ping:
        type = ping
        counts = 100
        flood_minutes = 10

    - jumbo:
        only Linux
        no RHEL.3.9
        no RHEL.4
        type = jumbo
        rtl8139:
            mtu = 1500
        e1000:
            mtu = 16110
        virtio_nic:
            mtu = 65520

    - file_transfer:
        type = file_transfer
        filesize = 4000
        transfer_timeout = 1000
        variants:
            - remote:
                transfer_type = remote

    - nicdriver_unload:
        only Linux
        type = nicdriver_unload
        nic_mode = tap
        filesize = 100
        transfer_timeout = 100
        transfer_type = remote
        sessions_num = 10

    - nic_promisc:
        only Linux
        type = nic_promisc
        file_size = 1, 1460, 65000, 100000000
        transfer_timeout = 1500
        transfer_type = remote

    - multicast:
        only Linux
        type = multicast
        nic_mode = tap
        mcast = 225.0.0.1
        mgroup_count = 20
        flood_minutes = 1

    - mac_change:
        only Linux
        type = mac_change
        kill_vm = yes

    - netperf: install setup image_copy unattended_install.cdrom
        only Linux
        type = netperf
        kill_vm = yes
        image_snapshot = yes
        # nic1 is for control, nic2 is for data connection
        # bridge_nic1 = virbr0
        pci_model_nic1 = virtio_net
        # bridge_nic2 = switch
        pci_model_nic2 = e1000
        nics += ' nic2'
        nic_mode = tap
        netperf_files = netperf-2.4.5.tar.bz2 wait_before_data.patch
        setup_cmd = "cd /tmp && rm -rf netperf-2.4.5 && tar xvfj netperf-2.4.5.tar.bz2 && cd netperf-2.4.5 && patch -p0 < ../wait_before_data.patch && ./configure && make"
        # configure netperf test parameters
        l = 60
        protocols = "TCP_STREAM TCP_MAERTS TCP_RR"
        sessions = "1 2 4"
        sessions_rr = "50 100 250 500"
        sizes = "64 256 512 1024"
        sizes_rr = "64 256 512 1024"
        numa_node = -1
        # this script is used to setup test env for (linux)guest/host
        # before performance testing
        # rh_perf_envsetup_script = scripts/rh_perf_envsetup.sh
        variants:
            - guest_guest:
                vms += " vm2"
                nics = 'nic1'
            - host_guest:
                # local host ip address
                # client = localhost
            - exhost_guest:
                # external host ip address
                # client =

    - ethtool:
        only Linux
        no rtl8139
        no RHEL.3.9
        type = ethtool
        filesize = 512
        nic_mode = tap
        supported_features = "tx rx sg tso"
        RHEL.4:
            e1000:
                supported_features = "tx rx sg tso"
            virtio_nic:
                supported_features = "tx sg tso"
        RHEL.5:
            e1000:
                supported_features = "tx rx sg tso gso"
            virtio_nic:
                supported_features = "tx sg tso gso"
        RHEL.6:
            # gso gro lro is only supported by latest kernel
            e1000:
                supported_features = "tx rx sg tso gso gro"
            virtio_nic:
                supported_features = "tx sg tso gso"

    - nic_bonding:
        only Linux
        type = nic_bonding
        nics += ' nic2 nic3 nic4'
        image_snapshot = yes
        serial_login = yes
        test_timeout = 1000
        filesize = 4000
        transfer_timeout = 1000
        transfer_type = remote
        kill_vm = yes

    - set_link:
        type = set_link
        test_timeout = 1000
        filesize = 4000
        transfer_timeout = 1000
        transfer_type = remote
        kill_vm =yes

    - netstress_kill_guest: install setup unattended_install.cdrom
        only Linux
        type = netstress_kill_guest
        image_snapshot = yes
        nic_mode = tap
        nic_module_cmd = "ls -l --color=never /sys/class/net/*/device/driver/module"
        # There should be enough vms for build topology.
        variants:
            -driver:
                mode = driver
            -load:
                mode = load
                netperf_files = netperf-2.4.5.tar.bz2 wait_before_data.patch
                packet_size = 1500
                setup_cmd = "cd %s && tar xvfj netperf-2.4.5.tar.bz2 && cd netperf-2.4.5 && patch -p0 < ../wait_before_data.patch && ./configure && make"
                clean_cmd = " while killall -9 netserver; do True test; done;"
                netserver_cmd =  %s/netperf-2.4.5/src/netserver
                netperf_cmd = %s/netperf-2.4.5/src/netperf -t %s -H %s -l 60 -- -m %s

    - physical_resources_check:
        type = physical_resources_check
        catch_uuid_cmd = dmidecode | awk -F: '/UUID/ {print $2}'
        mem_chk_re_str = ([0-9]+)
        monitor_type = human
        monitors = humanmonitor1
        main_monitor = humanmonitor1
        chk_timeout = 240
        mtype_pattern = '\d.\d.\d'
        check_machine_type_cmd = dmidecode | awk -F: '/Version: RHEL/'
        virtio_blk:
            vms = ""
            catch_serial_cmd = cat /sys/block/vda/serial; echo

    - ksm_overcommit:
        no Windows
        no hugepages
        pre_command = "grep -q el5 /proc/version && ([ -e /dev/ksm ] && true || modprobe ksm && ksmctl start 5000 50 ) || (echo 1 > /sys/kernel/mm/ksm/run && echo 5000 > /sys/kernel/mm/ksm/pages_to_scan && echo 50 > /sys/kernel/mm/ksm/sleep_millisecs); scripts/private_br.sh notftp;"
        post_command = "scripts/private_br.sh;"
        # Don't preprocess any vms as we need to change its params
        vms = ''
        image_snapshot = yes
        kill_vm_gracefully = no
        type = ksm_overcommit
        # Make host use swap (a value of 'no' will turn off host swap)
        ksm_swap = yes
        # Overcommit of host memmory
        ksm_overcommit_ratio = 3
        # Max paralel runs machine
        ksm_parallel_ratio = 4
        # Host memory reserve
        ksm_host_reserve = 512
        ksm_guest_reserve = 1024
        bridge = vbr0
        nic_script = scripts/qemu-ifup-vbr0
        variants:
            - ksm_serial:
                ksm_mode = "serial"
            - ksm_parallel:
                ksm_mode = "parallel"

    - iofuzz:
        only Linux
        type = iofuzz

    - cgroup:
        only Linux
        type = cgroup
        cgroup_test_time = 60
        cgroup_limit = 0.1
        # rmmod scsi_debug instead of writing into /sys/../add_host (safer)
        cgroup_rmmod_scsi_debug = "yes"
        variants:
            - blkio_bandwidth:
                # Test creates VMs with disks according to weights
                vms = ""
                # problem with multiple preprocess, turn off the screendumps
                take_regular_screendumps = "no"
                extra_params += " -snapshot"
                cgroup_test = "blkio_bandwidth"
                # cgroup_test_time, cgroup_weights, cgroup_limit{ ,_read,_write}
                # cgroup_weights = "[100, 1000, 500]"
            - blkio_throttle:
                # Test creats VMs with disks according to speeds
                vms = ""
                # problem with multiple preprocess, turn off the screendumps
                take_regular_screendumps = "no"
                extra_params += " -snapshot"
                cgroup_test = "blkio_throttle"
                # cgroup_test_time, cgroup_limit{ ,_read,_write}, cgroup_speeds
                # cgroup_speeds = [1024, 2048, 4096, 8192]
            - blkio_throttle_multi:
                # Test creats VMs with disks according to speeds
                vms = ""
                # problem with multiple preprocess, turn off the screendumps
                take_regular_screendumps = "no"
                extra_params += " -snapshot"
                cgroup_test = "blkio_throttle_multi"
                # cgroup_test_time, cgroup_limit{ ,_read,_write}, cgroup_speeds
                # cgroup_speeds = "[[0, 1024, 0, 2048, 0, 4096],"
                # cgroup_speeds += "[1024, 1024, 1024, 1024, 1024, 1024]]"
            - cpu_cfs_util:
                # Test creats VMs according to no_host_cpus
                # We want to be sure 1st VM have only 1 vCPU
                vms = vm1
                smp = 1
                extra_params += " -snapshot"
                cgroup_test = "cpu_cfs_util"
                # cgroup_test_time, cgroup_limit
            - cpu_share:
                # Test creats VMs according to smp and cgroup_speeds
                vms = ""
                # When smp = 0 => it sets smp = no_host_cpus (optimal for test)
                smp = 0
                # problem with multiple preprocess, turn off the screendumps
                extra_params += " -snapshot"
                cgroup_test = "cpu_share"
                # cgroup_test_time, cgroup_speeds
                # cgroup_speeds = "[1000, 10000, 100000]"
            - cpuset_cpus:
                cgroup_test = "cpuset_cpus"
                # cgroup_test_time, cgroup_limit, cgroup_cpuset, cgroup_verify
                cgroup_test_time = 10
                # smp have to match cpuset scenerios!
                # smp = 4
                # cgroup_cpuset = "[[None, '0,3', '1', '2', '1-2'],
                # cgroup_cpuset += "[None, '0', '1', '0-1', '0-1']]
                # cgroup_verify = [[50, 100, 100, 50], [100, 100, 5, 5]]
            - cpuset_cpus_switching:
                cgroup_test = "cpuset_cpus_switching"
                # cgroup_test_time
            - devices_access:
                cgroup_test = "devices_access"
            - freezer:
                cgroup_test = "freezer"
                # cgroup_test_time
            - memory_limit:
                # Test creats VMs
                cgroup_test = "memory_limit"
                # cgroup_memory_limit_kb(4kb aligned)
                # cgroup_memory_limit_kb = 2097152
            - memory_memsw_limit:
                # Test creats VMs
                cgroup_test = "memory_memsw_limit"
                # cgroup_memory_limit_kb(4kb aligned)
                # cgroup_memory_limit_kb = 2097152
            - memory_move:
                cgroup_test = "memory_move"
                # cgroup_test_time, cgroup_memory_move_mb
                # cgroup_memory_move_mb = 2048

    - virtio_console:
        no Host_RHEL.5
        only Linux
        no RHEL.3
        no RHEL.4
        vms = ''
        type = virtio_console
        # Use human monitor
        monitor_type = human
        monitors = humanmonitor1
        main_monitor = humanmonitor1
        # Default number of consoles
        virtio_console_no_serialports = 0
        virtio_console_no_consoles = 0

        # smoke params - $console_type:data_string
        # FIXME: test_smoke doesn't work with console yet (virtio_console bug)
        # "serialport;console:Custom data"
        smoke_test = yes
        virtio_console_smoke = "serialport"
        # loopback params - '$source_console_type@buffer_length:$destination_console_type1@buffer_length:...:$loopback_buffer_length;...'
        loopback_test = yes
        virtio_console_loopback = "serialport:serialport;serialport@1024:serialport@32:console@1024:console@8:16"
        # perf params - $console_type@buffer_length:$test_duration
        # FIXME: test_perf doesn't work with console yet (virtio_console bug)
        # virtio_console_perf = "serialport;serialport@1000000:120;console@1024:60"
        perf_test = yes
        virtio_console_perf = "serialport;serialport@1000000:120"
        # Enable destructive tests: "test_name  = yes"
        # Disable test: change yes or delete key.
        rmmod_test = yes
        max_ports_test = yes
        shutdown_test = yes

        # Offline migration params - '$console_type:$no_migrations:$send-:$recv-$loopback-buffer_length'
        migrate_offline_test = yes
        virtio_console_migration_offline = "serialport:1:2048:2048:2048;serialport:5:4096:4096:4096"

        # Online migration params - '$console_type:$no_migrations:$send-:$recv-$loopback-buffer_length'
        migrate_online_test = yes
        virtio_console_migration_online = "serialport:1:2048:2048:2048;serialport:5:4096:4096:4096"

        hotplug_test = yes
        hotplug_serial_test = yes
        hotplug_console_test = no

    # This unit test module is for older branches of KVM that use the
    # kvmctl test harness (such as the code shipped with RHEL 5.x)
    - unit_test_kvmctl:
        type = unittest_kvmctl
        vms = ''
        profilers = ''
        variants:
            - access:
                case = access
            - apic:
                case = apic
            - emulator:
                case = emulator
            - hypercall:
                case = hypercall
            - msr:
                case = msr
            - port80:
                case = port80
            - realmode:
                case = realmode
            - sieve:
                case = sieve
            - smptest:
                case = smptest
            - tsc:
                case = tsc
            - stringio:
                case = stringio
            - vmexit:
                case = vmexit


    - fillup_disk:
        only Linux
        only qcow2
        type = fillup_disk
        fillup_timeout = 120
        fillup_size = 200
        fillup_cmd = "dd if=/dev/zero of=/%s/fillup.%d bs=%dM count=1 oflag=direct"
        kill_vm = yes

    - lvm:
        only Linux
        no RHEL.3.9
        images += ' stg1 stg2'
        image_name_stg1 = 'storage_4k'
        image_name_stg2 = 'storage_64k'
        image_format_stg1 = qcow2
        image_format_stg2 = qcow2
        index_enable = no
        guest_testdir = /mnt
        disks = "/dev/hdb /dev/hdc"
        kill_vm = no
        post_command_noncritical = no
        RHEL.6:
            disks = "/dev/sdb /dev/sdc"
        virtio_blk:
            disks = "/dev/vdb /dev/vdc"
        variants:
            lvm_create:
                type = lvm
                clean = no
                pre_command = 'cp -f /mnt/linux/storage_4k.qcow2 /mnt/linux/storage_64k.qcow2 /home/kvm_autotest_root/images/'
            lvm_fill: lvm_create
                type = fillup_disk
                fillup_timeout = 120
                fillup_size = 20
                fillup_cmd = "dd if=/dev/zero of=/%s/fillup.%d bs=%dM count=1 oflag=direct"
                RHEL.4:
                    fillup_cmd = "dd if=/dev/zero of=/%s/fillup.%d bs=%dM count=1"
            lvm_ioquit: lvm_create
                type = ioquit
                kill_vm = yes
                background_cmd = "for i in 1 2 3 4; do (nohup dd if=/dev/urandom of=/mnt/file bs=102400 count=10000000 &) done; while true; do sync; done"
                check_cmd = pgrep dd
                check_img = yes

    - ioquit:
        only Linux
        only qcow2
        type = ioquit
        kill_vm = yes
        background_cmd = "for i in 1 2 3 4; do (nohup dd if=/dev/urandom of=/tmp/file bs=102400 count=10000000 &) done; while true; do sync; done"
        check_cmd = pgrep dd
        check_img = yes
        post_command_noncritical = no

    - multi_disk:
        no ide
        type = multi_disk
        usbs = ""
        usb_devices = ""
        force_create_image = yes
        force_create_image_image1 = no
        remove_image = yes
        remove_image_image1 = no
        cmd_timeout = 1000
        block_list = C: D: vda vda1 vda2 hda hda1 hda2
        variants:
            - default:
                no virtio_blk
                images += " stg stg2 stg3"
                image_format_stg = qcow2
                image_name_stg = storage
                image_size_stg = 1G
                image_format_stg2 = qcow2
                image_name_stg2 = storage2
                image_size_stg2 = 10G
                image_format_stg3 = raw
                image_name_stg3 = storage3
                image_size_stg3 = 5G
            - max_disk:
                drive_pci_addr_image1 = 4
                drive_format = virtio
                stg_image_num = 24
                stg_image_size = 5G
                stg_image_boot = no
                # other variants.
                # stg_image_format = qcow2
                # stg_drive_format = virtio
                # stg_assign_index = yes
                Linux:
                    image_size_image1 = 20G
                Windows:
                    image_size_image1 = 30G

    - clock_getres:
        no Windows
        no RHEL.3
        no RHEL.4
        type = clock_getres

    - yum_update: install setup image_copy unattended_install.cdrom
        only Fedora, RHEL
        type = yum_update
        shell_prompt = "Is this ok"

    - kdump:
        only Linux
        no RHEL.3.9
        no RHEL.4
        type = kdump
        # time waited for the completion of crash dump
        # crash_timeout = 360
        # command to add the crashkernel=X@Y to kernel cmd line
        # RHEL-Server-5.X ONLY support parameter crashkernel=X@Y
        RHEL.5:
            kernel_param_cmd = "grubby --update-kernel=`grubby --default-kernel` --args=crashkernel=128M@16M"
        # RHEL-Server-6.X need reserve more RAM for kdump service
        RHEL.6:
            kernel_param_cmd = "grubby --update-kernel=`grubby --default-kernel` --args=crashkernel=256M@0M"

        # command to enable kdump service
        # kdump_enable_cmd = chkconfig kdump on && service kdump start
        # command to probe the crash kernel
        # crash_kernel_prob_cmd = "grep -q 1 /sys/kernel/kexec_crash_loaded"
        # crash_cmd = "echo c > /proc/sysrq-trigger"
        variants:
            - @default:
            - nmi:
                kernel_param_cmd = "grubby --update-kernel=`grubby --default-kernel` --args='crashkernel=128M nmi_watchdog=1'"
                crash_cmd = nmi

    - vmstop:
        type = vmstop
        # the path used to store the saved vm state
        # save_path = /tmp
        # clean the state file?
        clean_save = yes

    - cdrom_test:
        only Linux
        no RHEL.3.9
        type = cdrom
        pre_command = "dd if=/dev/urandom of=orig bs=10M count=1 && dd if=/dev/urandom of=new bs=10M count=1 && mkisofs -o /tmp/orig.iso orig && mkisofs -o /tmp/new.iso new"
        new_iso = /tmp/new.iso
        max_times = 20
        filename = new
        kill_vm = yes
        post_command = rm -rf /tmp/orig.iso /tmp/new.iso orig new
        cdrom_cd1 = /tmp/orig.iso

    - floppy_test:
        type = floppy
        floppy = "images/test_floppy.img"
        pre_command = "dd if=/dev/zero of=images/test_floppy.img bs=512 count=2880"

    - usb_storage:
        only Linux
        no Host_RHEL.5
        no Host_RHEL.6.1
        type = usb
        kill_vm = yes
        format_timeout = 400
        # Disable other usb devices
        usb_devices = ""
        usbs = usb1
        usb_type_usb1 = usb-ehci
        usb_max_port_usb1 = 6
        images += " stg"
        image_name_stg = "usbdevice"
        image_format_stg = "qcow2"
        image_boot_image1 = yes
        image_boot_stg = no
        drive_format_stg = "usb2"
        drive_index_stg = 1
        create_image_stg = yes
        image_size_stg = 10M
        fdisk_string = "10 MB, 10485760 bytes"
        variants:
            - @default:
            - check_options:
                check_serial_option = yes
                check_removable_option = yes
                check_io_size_option = yes
                check_freq_option = yes

    - usb_multi_disk: install setup image_copy unattended_install.cdrom
        no RHEL.3.9
        no Host_RHEL.5
        no Host_RHEL.6.1
        type = multi_disk
        cmd_timeout = 1000
        block_list = C: D: vda vda1 vda2 hda hda1 hda2 sda sda1 sda2
        kill_vm = yes
        create_image = yes
        image_boot_image1 = yes
        # Disable other usb devices
        usb_devices = ""
        usbs = usb1
        usb_type_usb1 = usb-ehci
        usb_type = usb-ehci
        usb_max_port_usb1 = 6
        usb_max_port = 6
        variants:
            - signal_repeat:
                images += " stg"
                image_format_stg = qcow2
                image_name_stg = storage
                image_size_stg = 1G
                drive_format_stg = usb2
                drive_index_stg = 1
                image_boot_stg = no
                force_create_image_stg = yes
                remove_image_stg = yes
                n_repeat = 10
            - max_disk:
                start_vm = no
                usbs += " usb2 usb3 usb4"
                stg_image_num = 24
                stg_image_size = 1G
                stg_image_boot = no
                stg_drive_format = usb2
                stg_assign_index = yes
                remove_image = yes
                remove_image_image1 = no
                cmd_timeout = 1000

    - nmi_watchdog:
        no Host_RHEL.5
        only Linux
        type = nmi_watchdog
        get_nmi_cmd = grep NMI /proc/interrupts
        nmi_watchdog_type = 1
        image_snapshot = yes

    - trans_hugepage:
        no Host_RHEL.5
        only Linux
        setup_thp = "yes"
        thp_default_config = "/tmp/thp_default_config"
        thp_test_config = ""
        kill_vm = yes
        login_timeout = 360
        variants:
            - base:
                type = trans_hugepage
                dd_timeout = 900
            - defrag:
                type = trans_hugepage_defrag
            - swapping:
                type = trans_hugepage_swapping
                dd_timeout = 900
                check_cmd_timeout = 900
            - migration:
                type = migration
                migration_test_command = help
                migration_bg_command = "mkdir -p /space; mount -t tmpfs none /space; while true; do dd if=/dev/zero of=/space/zero bs=4M count=1M;done"
                migration_bg_check_command = "pidof dd"
                migration_bg_kill_command = "killall dd"
            - relocated:
                type = trans_hugepage_relocated
                thp_test_config = "/sys/kernel/mm/redhat_transparent_hugepage/khugepaged/pages_to_scan:4096;/sys/kernel/mm/redhat_transparent_hugepage/khugepaged/scan_sleep_millisecs:10000;/sys/kernel/mm/redhat_transparent_hugepage/khugepaged/alloc_sleep_millisecs:60000"
            - memory_stress:
                type = trans_hugepage_memory_stress
                thp_memory_stress = autotest
                test_name = stress_memory_heavy
                test_control_file = stress_memory_heavy.control
                test_timeout = 600
                qemu_mem = 128
                hugetlbfs_path = "/proc/sys/vm/nr_hugepages"

    - cpuflags:
        only Linux
        type = cpuflags
        auto_cpu_model = "no"
        extra_params += " -snapshot"
        #Disable all unnecessary vms.
        vms = ""
        #Try to start guest with all flags which are supported by host.
        all_host_supported_flags = "no"
        cpu_model = "core2duo"
        guest_spec_flags = "fxsr_opt hypervisor ds pdpe1gb osxsave svm"
        host_spec_flags = "pbe tm ds_cpl monitor acpi dtes64 ht tm2 xtpr est pdcm smx"
        variants:
            - interface:
                variants:
                    - qemu_cpu_model:
                        test_type = "test_qemu_cpu_model"
                    - qemu_cpu_dump:
                        test_type = "test_qemu_dump"
                    - qemu_cpu_cpuid:
                        test_type = "test_qemu_cpuid"
            - boot_guest:
                variants:
                    - qemu_boot_cpu_model:
                        test_type = "test_boot_cpu_model"
                    - qemu_boot_cpu_model_and_flags:
                        test_type = "test_boot_cpu_model_and_additional_flags"
                    - qemu_warn_boot_check_cpu_model:
                        test_type = "test_boot_warn_with_host_unsupported_flags"
                    - qemu_boot_fail_cpu_model:
                        test_type = "test_fail_boot_with_host_unsupported_flags"
            - stress_guest:
                variants:
                    - qemu_test_boot_guest_and_try_flags_under_load:
                        test_type = "test_boot_guest_and_try_flags_under_load"
                    - qemu_test_online_offline_guest_CPUs:
                        test_type = "test_online_offline_guest_CPUs"
                    - qemu_test_migration_with_additional_flags:
                        test_type = "test_migration_with_additional_flags"

    - cpuflags_multi_host:
        type = cpuflags
        test_type = test_multi_host_migration
        vms = "vm1"
        start_vm = no
        #Try to start guest with all flags which are supported by host.
        all_host_supported_flags = "no"
        cpu_model = "core2duo:sse3"
        guest_spec_flags = "fxsr_opt hypervisor ds pdpe1gb osxsave svm"
        host_spec_flags = "pbe tm ds_cpl monitor acpi dtes64 ht tm2 xtpr est pdcm smx"
        mig_timeout = 4800
        kill_vm_on_error = yes
        disk_prepare_timeout = 360
        comm_port = 13234
        regain_ip_cmd = killall dhclient; sleep 10; dhclient;

    - cpu_hotplug_test:
        type = cpu_hotplug
        cpu_hotplug_timeout = 600
        n_cpus_add = 1
        kill_vm = yes
        iterations = 5
        onoff_iterations = 100

    - hdparm:
        only Linux
        type = hdparm
        get_disk_cmd = \ls /dev/[vhs]da
        low_status_cmd = hdparm -a64 -d0 -u0 %s
        device_cache_read_cmd = hdparm -tT %s
        high_status_cmd = hdparm -a256 -d1 -u1 %s
        cmd_timeout = 540
        virtio_blk:
            no RHEL.3.9
            get_disk_cmd = \ls /dev/vda
            low_status_cmd = hdparm -a32 -r0 %s
            high_status_cmd = hdparm -a256 -r1 %s

    - getfd: install setup image_copy unattended_install.cdrom
        type = getfd
        restart_vm = yes
        kill_vm = yes
        number_of_files = 900

    # system_powerdown, system_reset and shutdown *must* be the last ones
    # defined (in this order), since the effect of such tests can leave
    # the VM on a bad state.
    - system_powerdown:
        type = shutdown
        shutdown_method = system_powerdown
        sleep_before_powerdown = 20
        kill_vm = yes
        kill_vm_gracefully = no

    - system_reset:
        type = boot
        reboot_method = system_reset
        sleep_before_reset = 20
        kill_vm_on_error = yes

    - system_reset_bootable:
        type = system_reset_bootable
        interval = 1
        reset_times = 20
        wait_time_for_reset = 120
        kill_vm_on_error = yes

    - 9p: install setup image_copy unattended_install.cdrom
        only Linux
        type = 9p
        9p_mount_dir = /root/mount1
        9p_posix_acl = yes
        9p_guest_cache = yes
        9p_proto_version = 9p2000.L
        test_timeout = 1800
        variants:
            - 9p_ci:
                test_control_file = 9p-ci.control
                test_timeout = 1800

    - shutdown:
        type = shutdown
        shutdown_method = shell
        kill_vm = yes
        kill_vm_gracefully = no
        check_img = yes

# Above lines are reserved for upstream.
# Please Don't add any case before shutdown.
# Below cases are only existed in internal tree.
#
    - build:
        testcase = build
        type = build
        mode = brew
        load_modules = yes
        base_pgk_url = http://download.devel.redhat.com/brewroot/packages/
        release = kvm-83-142.el5
        pkg_list = kmod-kvm kvm kvm-qemu-img kvm-tools kvm-debuginfo
        qemu_bin_paths = /usr/libexec/qemu-kvm /usr/bin/qemu-img
        vms =

    - check_block_size:
        only Linux
        only virtio_blk
        type = check_block_size
        kill_vm = yes
        kill_vm_gracefully = yes
        kill_vm_on_error = yes
        index_enable = no
        image_name_stg = "check_block_size_image"
        image_size_stg = 20G
        force_create_image_stg = yes
        get_dev_list_cmd = "cd /dev && ls vd?"
        chk_phy_blk_cmd = "cat /sys/block/%s/queue/physical_block_size"
        chk_log_blk_cmd = "cat /sys/block/%s/queue/logical_block_size"
        variants:
            4096_4096:
                need_install = no
                images += " stg"
                physical_block_size_stg = 4096
                logical_block_size_stg = 4096
            4096_512:
                need_install = yes
                start_vm = no
                images = "stg"
                boot_drive_stg = yes
                medium = cdrom
                installation = cdrom
                kernel = vmlinuz
                initrd = initrd.img
                nic_mode = tap
                physical_block_size_stg = 4096
                logical_block_size_stg = 512
            512_512:
                need_install = yes
                start_vm = no
                images = "stg"
                boot_drive_stg = yes
                medium = cdrom
                installation = cdrom
                kernel = vmlinuz
                initrd = initrd.img
                nic_mode = tap
                physical_block_size_stg = 512
                logical_block_size_stg = 512

    - qemu_iotests:
        no Host_RHEL.5
        type = qemu_iotests
        vms = ''
        download_cmd = "git clone"
        rsc_server = "git://qe-git.englab.nay.redhat.com/s2/qemu-iotests-rhel6"
        variants:
            - qcow2_image:
                image_type = "qcow2"
            - raw_image:
                image_type = "raw"

    - rh_kernel_update:
        only Linux
        no RHEL.3.9
        type = rh_kernel_update
        rpm_timeout = 1200
        kernel_version = 2.6.18-164.8.1.el5
        kernel_rpm = http://download.devel.redhat.com/brewroot/packages/kernel/2.6.18/164.8.1.el5/x86_64/kernel-2.6.18-164.8.1.el5.x86_64.rpm
        args_removed = "rhgb quiet"
        args_added = "console=ttyS0,115200 console=tty0"
        method = brew
        install_virtio = no
        verify_virtio = no
        virtio_nic, virtio_blk:
            install_virtio = yes
            verify_virtio = yes

    - kernel_install:
        type = kernel_install
        variants:
            - brew:
                install_type = brew
                kernel_dep_pkgs = "kernel-firmware"
            ## Example for other installation methods
            #- rpm:
            #    install_type = rpm
            ## These 2 parameter can be a url.
            #    kernel_rpm_path = "kernel-2.6.32-220.el6.i686.rpm"
            #    kernel_deps_rpms = "kernel-firmware-2.6.32-220.el6.noarch.rpm"
            #- git:
            #    install_type = git
            #    kernel_git_repo = ""
            #    kernel_git_repo_base = ""
            #    kernel_git_branch = ""
            #    kernel_git_commit = ""
            #    kernel_patch_list = ""
            #    kernel_config = ""
            #    kerne_config_list = ""
            #- tar:
            #    install_type = tar
            #    kerne_src_pkg = "http://fileshare.englab.nay.redhat.com/pub/section2/kvm/pub/test_src/linux-2.6.34.tar.bz2"
            #    kernel_config = "http://fileshare.englab.nay.redhat.com/pub/section2/kvm/pub/test_src/config-64"
            #    kernel_patch_list = ""
            #    kernel_tag = "2.6.34"

    - vnc_test:
        no RHEL_Server_5.7_host
        no RHEL_Server_5.8_host
        type = vnc
        vnc_password = 'yes'
        rfb_version = 3.3 3.7 3.8
        change_passwd_cmd = "set_password protocol=vnc,password=%s;expire_password protocol=vnc,time=+%s"

    - cross_host_migrate:
        type = cross_host_migration
        migration_test_command = help
        migration_bg_command = "cd /tmp; nohup ping localhost"
        migration_bg_check_command = pgrep ping
        migration_bg_kill_command = pkill ping
        kill_vm_on_error = yes
        iterations = 2
        max_vms = 2
        used_mem = 1024
        mig_timeout = 3600
        guest_stress_test = stress
        monitor_type = human
        monitors = humanmonitor1
        main_monitor = humanmonitor1
        # you can uncomment the following line to enable the state
        # check
        # vmstate_check = yes
        variants:
            - tcp:
                migration_protocol = "tcp"
            - exec:
                migration_protocol = "exec"
        variants:
            - @default:
                guest_stress_test = ""
            - with_dd:
                guest_stress_test = "dd"
            - with_iozone:
                guest_stress_test = "iozone"
            - with_stress:
                guest_stress_test = "stress"
            - with_set_downtime1:
                mig_downtime = 5s
                pre_migrate = "mig_set_downtime"
            - with_set_downtime2:
                mig_downtime = 5s
                during_migrate = "mig_set_downtime"
            - with_mig_cancel:
                only tcp
                during_migrate = "mig_cancel"
            - with_guest_pause1:
                only tcp
                pre_migrate = "guest_stop"
            - with_guest_pause2:
                only tcp
                during_migrate = "guest_stop"
            - with_set_speed:
                mig_speed = 1G
                during_migrate = "mig_set_speed"
            - with_reboot:
                migration_bg_command = ""
                migration_bg_check_command = ""
                migration_bg_kill_command = ""
                guest_stress_test = ""
                pre_migrate = "guest_reboot"
            - with_boot:
                start_vm = no
                migration_bg_command = ""
                migration_bg_check_command = ""
                migration_bg_kill_command = ""
                guest_stress_test = ""
                pre_migrate = "guest_boot"
            - ping_pong_transfer:
                pre_migrate = "bg_file_transfer_start"
                post_migrate = "bg_file_transfer_stop"
                guest_stress_test = ""
                ping_pong = 10
            - ping_pong_io:
                guest_stress_test = "iozone"
                ping_pong = 10

    - cross_host_transfer:
        type = cross_host_transfer
        file_size = 4000
        transfer_timeout = 1000
        vms += " vm2"
        listen_ip = "0.0.0.0"
        image_snapshot = yes

    - readonly_floppy:
        type = readonly_floppy
        floppy = "images/fd1.img images/fd2.img"
        pre_command = "dd if=/dev/urandom of=images/fd1.img bs=512 count=2880&&  dd if=/dev/urandom of=images/fd2.img bs=512 count=2880"
        format_floppy_timeout = 60
        floppy_readonly = "True True"

    - netperf2:    install setup
        only Linux
        no RHEL.3.9
        type = netperf2
        image_snapshot = yes
        vms += " vm2"
        client_vm = vm2

    - ntttcp:
        only Windows
        type = ntttcp
        image_snapshot = yes
        check_ntttcp_cmd = "cmd /c dir C:\NTttcp"
        ntttcp_sender_cmd = "cmd /c C:\NTttcp\NTttcps.exe -m %s,0,%s -a 2 -l %s"
        ntttcp_receiver_cmd = "cmd /c C:\NTttcp\NTttcpr.exe -m %s,0,%s -a 6 -rb 256k"
        session_num = 1
        buffers = "2k 4k 8k 16k 32k 64k 128k 256k"
        timeout = 300
        kill_vm = yes
        variants:
            - guest_guest:
                vms += " vm2"
            - guest_host:
                # external Windows IP
                receiver_address = "192.168.1.1"
        32:
            ntttcp_install_cmd = 'cmd /c "D:\autoit3.exe D:\NTttcp\NTttcp.au3 && mkdir C:\NTttcp && copy "C:\Program Files\Microsoft Corporation\NT Testing TCP Tool\*" C:\NTttcp && cd C:\NTttcp\ && copy NTttcp_%s.exe NTttcps.exe && copy NTttcp_%s.exe NTttcpr.exe"'
        64:
            ntttcp_install_cmd = 'cmd /c "D:\autoit3.exe D:\NTttcp\NTttcp.au3 && mkdir C:\NTttcp && copy "C:\Program Files (x86)\Microsoft Corporation\NT Testing TCP Tool\*" C:\NTttcp && cd C:\NTttcp\ && copy NTttcp_%s.exe NTttcps.exe && copy NTttcp_%s.exe NTttcpr.exe"'

    - cross_host_netperf:    install setup
        type = cross_host_netperf
        image_snapshot = yes
        variants:
            - host_remotehost:
                client_type = host
                server_type = remotehost
                vms = ""
            - host_guest:
                client_type = host
                server_type = guest
                server_vm = vm1
            - guest_host:
                client_type = guest
                server_type = host
                client_vm = vm1
            - guest_guest:
                client_type = guest
                server_type = guest
                vms += " vm2"
                client_vm = vm1
                server_vm = vm2
            - guest_remotehost:
                client_type = guest
                server_type = remotehost
                client_vm = vm1
            - remotehost_guest:
                client_type = remotehost
                server_type = guest
                server_vm = vm1

    - acpi_after_hotplug:
        type = acpi_after_hotplug
        pci_type = block
        images += " stg"
        boot_drive_stg = no
        image_name_stg = storage
        image_size_stg = 1G
        remove_image_stg = yes
        force_create_image_stg = yes
        kill_vm_on_error = yes
        kill_vm_gracefully = no
        image_format_stg = qcow2
        pci_model = virtio
        match_string = "Virtio block device"
        variants:
            - acpi_guest_s3:
                no RHEL.3.9
                no RHEL.4
                sub_type = guest_s3
            - acpi_guest_s4:
                no RHEL.3.9
                no RHEL.4
                sub_type = guest_s4
            - acpi_shutdown:
                sub_type = shutdown
                shutdown_method = shell
                check_img = yes
            - acpi_reboot:
                sub_type = boot
                reboot_method = shell
                reboot = yes

    - ipi_x2apic:
        no Host_RHEL.5
        only RHEL.6
        type = ipi_x2apic
        vms = ""
        check_x2apic_cmd = dmesg |grep x2apic
        enable_x2apic = yes
        run_pipetest_cmd = "cd /tmp/ && gcc -o pipetest pipetest.c && ./pipetest && cd"
        x2apic_check_string = Enabling x2apic, Enabled x2apic, Setting APIC routing to physical x2apic
        pre_command += " grep 'flags' /proc/cpuinfo|grep 'ept' && modprobe -r kvm_intel && modprobe kvm_intel ept=1 || echo ok;"

    - stress_kernel_compile:
       only Linux
       type = stress_kernel_compile
       image_snapshot = yes
       vms = ""
       overcommit = 1.5
       query_cmd = grep MemTotal /proc/meminfo | awk '{print $2}'
       test_src = "http://fileshare.englab.nay.redhat.com/pub/section2/kvm/gyue/linux-2.6.32.tar.bz2"
       test_cmd = "(tar xfj linux-2.6.32.tar.bz2 && cd linux-2.6.32 && make defconfig && make -j `grep processor /proc/cpuinfo | wc -l`) > /dev/null"

    - qemu_io:
        only Linux
        only qcow2
        type = qemu_io
        vms = ''
        variants:
            - file_based:
            - lvm_based:
                pre_command += " qemu-img create -f raw 0.raw 10G && qemu-img create -f raw 1.raw 10G && losetup /dev/loop0 0.raw && losetup /dev/loop1 1.raw && pvcreate /dev/loop0 /dev/loop1 && vgcreate vg /dev/loop0 /dev/loop1 && lvcreate -L10G -n lv vg"
                post_command += " lvremove -f vg ; losetup -d /dev/loop0 ; losetup -d /dev/loop1; rm -rf /dev/vg; rm -rf *.raw;"
                pre_command_noncritical = no
                post_command_noncritical = no
                test_image= /dev/vg/lv

    - multi_nics: guest_test.arp_set
        only Linux
        no RHEL.3.9
        nics += ' nic2 nic3 nic4 nic5 nic6 nic7 nic8'
        kill_vm = no
        mac_filter = "HWaddr (.\w+:\w+:\w+:\w+:\w+:\w+)"
        ip_filter = "inet addr:(.\d+.\d+.\d+.\d+)"
        net_check_cmd = "ifconfig"
        strick_check = ""
        flood_minutes = 1
        transfer_timeout = 1000
        variants:
            - multi_nics_verify:
                type = multi_nics_verify
                reboot = yes
            - n_nics:
                type = multi_nics
                ping_counts = 10

    - nx:
        only Linux
        no RHEL.4
        only 64
        type = nx
        image_snapshot = yes
        kill_vm = yes
        variants:
            - noexec_on:
                nx_on = yes
            - noexec_off:
                cpu_model = qemu64
                cpu_model_flags = -nx
                nx_on = no

    - yonit_bitmap_benchmark:
        only Windows
        type = yonit_bitmap
        test_name = "yonit_bitmap_benchmark"
        reboot = no
        test_timeout = 86400
        download = yes
        download_cmd = "git clone"
        rsc_server = "git://qe-git.englab.nay.redhat.com/s2/yonit_bitmap_benchmark"
        dst_rsc_dir = "C:\"
        dst_rsc_path = "C:\yonit_bitmap_benchmark\prod"
        interpreter = "cmd /c C:\yonit_bitmap_benchmark\display_prog\compress_benchmark_loop.exe"
        script_params = " 0 "

    - screendump:
        type = screendump
        scrdump_count = 200
        scrdump_time_interval = 1.0
        kill_vm_on_error = yes
        reboot_method = shell
        sleep_before_reset = 10

    - tsc_drift:
        only Linux
        type = tsc_drift
        drift_threshold = 10
        interval = 30
        required_cpu_flags = "constant_tsc"
        pre_command = "/usr/bin/python scripts/check_cpu_flag.py"

    - format_disk:
        type = format_disk
        images += " disk1"
        boot_drive_disk1 = yes
        image_name_disk1 = storage
        image_size_disk1 = 10G
        force_create_image_disk1 = yes
        writefile_cmd = echo
        kill_vm = yes
        cmd_timeout = 1200

    - create_image:
        type = stub
        force_create_image = yes

    - qemu_killer_report:
        type = qemu_killer_report

    - netperf_udp:
        only Linux
        type = netperf_udp
        image_snapshot = yes
        hostpasswd = redhat
        message_size_range = 580 590 1
        netperf_path = %s/../netperf2/netperf-2.4.5.tar.bz2
        patch_path = %s/../netperf2/wait_before_data.patch
        setup_cmd = tar xvfj netperf-2.4.5.tar.bz2 && cd netperf-2.4.5 && patch -p0 < ../wait_before_data.patch && ./configure && make
        netserver_cmd = src/netserver
        netperf_cmd = src/netperf -l 10 -H %s -t UDP_STREAM -- -m %s
        failratio = 0.1

    - ext_server_job:
        only Linux
        testcase = "ext_server_job"
        description= "run test on external autotest server"
        asvr_ip = "kvm-autotest.englab.nay.redhat.com"
        asvr_user = "root"
        asvr_passwd = "123456"
        vms = "vm1"
        kill_vm = no
        asvr_job_timeout = 3600
        atest_basedir = "/usr/local/autotest/cli"
        get_tm_list_cmd = "atest host list"
        variants:
            - register_test_vm:
                type = ext_register_vm
                testcase = "register_test_vm"
                description = "register the VM to autotest server"
                add_host_cmd = "atest host create %s"
            - ext_test:    register_test_vm
                image_snapshot = yes
                type = ext_test
                testcase = "ext_test"
                asvr_job_timeout = 1200
                let_svr_breath = 10
                create_job_cmd = "atest job create -n -t %s -m %s %s"
                query_job_cmd = "atest job list -r"
                stat_job_cmd = "atest job stat %s"
                stat_tm_cmd = "atest host stat %s"
                # wait for the testing (virtual) machine to clean up
                wait_tm_cleanup = yes
                testname = "dbench"
                job_tag = "-katc-"
                version_tag = "kvm_auto"
                iterations = 10
            - unregister_test_vm:    register_test_vm
                type = ext_unregister_vm
                testcase = "ext_unregister_vm"
                unregister_cmd = 'atest host delete %s'
                kill_vm = yes

    - disable_win_update:
        only Windows
        type = disable_win_update
        stop_update_service_cmd = net stop WuAuServ
        disable_update_service_cmd = sc delete WuAuServ

    - qemu_img_check:
        only qcow2
        vms = ''
        type = stub
        post_command_noncritical = no
        check_image = yes
        post_command_timeout = 600

    - check_unhalt_vcpu:
        testcase = 'check_unhalt_vcpu'
        type = check_unhalt_vcpu
        images += " unbootable"
        boot_drive = no
        boot_drive_unbootable = yes
        image_boot_unbootable = yes
        image_name_unbootable = unbootable
        image_size_unbootable = 10M
        image_format_unbootable = qcow2
        force_create_image_unbootable = yes
        kill_vm = yes
        remove_image_unbootable = yes

    - audio:
        only Linux
        no RHEL.3.9
        testcase = 'audio'
        type = audio
        soundcards = ac97
        random_content_size = 100K
        audio_test_cmd = test -c /dev/dsp && dd if=/dev/urandom of=/dev/dsp bs=%s count=1

    - image_remove:
        kill_vm = yes
        type = stub
        remove_image = yes

    - ksm_base:
        only Linux
        type = ksm_base
        status_query_cmd = "cat /sys/kernel/mm/ksm/run"
        setup_cmd = "echo 1 > /sys/kernel/mm/ksm/run"
        shared_mem = 1024
        query_cmd = "cat /sys/kernel/mm/ksm/pages_sharing"
        split = "yes"
        variants:
            - disable:
                test_type = "disable"
                split = "no"
                extra_params += " -redhat-disable-KSM"
            - base:
                test_type = "base"
            - negative:
                test_type = "negative"
                random_bits = 21

    - qmp_event_notification:
        no Host_RHEL.5
        type = qmp_event_notification
        pre_command += "/usr/libexec/qemu-kvm --help|grep '\-qmp' || echo 'Qemu-kvm does not support qmp!';"
        check_timeout = 360
        monitors = ' humanmonitor1 qmp1 qmp2'
        monitor_type_qmp1 = qmp
        main_monitor = humanmonitor1
        monitor_type = human
        monitor_type_qmp2 = qmp
        variants:
            - qmp_quit:
                event_cmd = quit
                event_cmd_type = qmp_cmd
                event_check = "SHUTDOWN"
            - qmp_system_reset:
                event_cmd = system_reset
                event_cmd_type = qmp_cmd
                event_check = "RESET"
            - qmp_system_powerdown:
                event_cmd = system_powerdown
                event_cmd_type = qmp_cmd
                event_check = "POWERDOWN"
            - qmp_stop:
                event_cmd = stop
                post_event_cmd = c
                event_cmd_type = monitor_cmd
                event_check = "STOP"
            - qmp_resume:
                pre_event_cmd = stop
                event_cmd = c
                event_cmd_type = monitor_cmd
                event_check = "RESUME"
            - qmp_rtc_change:
                no Windows
                event_cmd = hwclock --systohc
                event_cmd_type = guest_cmd
                event_check = "RTC_CHANGE"
            - qmp_watchdog:
                no Windows
                event_cmd = echo 0 > /dev/watchdog
                event_cmd_type = guest_cmd
                event_check = "WATCHDOG"
                variants:
                    - qmp_pause:
                        extra_params += " -watchdog i6300esb -watchdog-action pause "
                        action_check = "pause"
                    - qmp_reset:
                        extra_params += " -watchdog i6300esb -watchdog-action reset "
                        action_check = "reset"
                    - qmp_poweroff:
                        extra_params += " -watchdog i6300esb -watchdog-action poweroff "
                        action_check = "poweroff"
                    - qmp_shutdown:
                        extra_params += " -watchdog i6300esb -watchdog-action shutdown "
                        action_check = "shutdown"
                    - qmp_debug:
                        extra_params += " -watchdog i6300esb -watchdog-action debug "
                        action_check = "debug"
                    - qmp_none:
                        extra_params += " -watchdog i6300esb -watchdog-action none "
                        action_check = "none"

    - qmp_command:
        no Host_RHEL.5
        type = qmp_command
        pre_command += "/usr/libexec/qemu-kvm --help|grep '\-qmp' || echo 'Qemu-kvm does not support qmp!';"
        monitors = ' humanmonitor1 qmp1 qmp2'
        monitor_type_qmp1 = qmp
        monitor_type_qmp2 = qmp
        monitor_type = human
        main_monitor = humanmonitor1
        event_cmd_type = monitor_cmd
        variants:
            - qmp_query-kvm:
                qmp_cmd = "query-kvm"
                post_cmd = "info kvm"
                cmd_result_check = equal
                cmd_return_value = "{u'enabled': True, u'present': True}"
            - qmp_query-mice:
                qmp_cmd = "query-mice"
                post_cmd = "info mice"
                cmd_result_check = contain
                cmd_return_value = "u'name': u'QEMU PS/2 Mouse';u'name': u'QEMU USB Tablet'"
            - qmp_query-status:
                pre_cmd = stop
                qmp_cmd = "query-status"
                post_cmd = "c"
                cmd_result_check = equal
                cmd_return_value = "{u'status': u'paused', u'singlestep': False, u'running': False}"
            - qmp_query-name:
                qmp_cmd = "query-name"
                post_cmd = "info name"
                cmd_result_check = m_in_q
            - qmp_query-uuid:
                qmp_cmd = "query-uuid"
                post_cmd = "info uuid"
                cmd_result_check = m_in_q
            - qmp_query-version:
                qmp_cmd = query-version
                post_cmd = info version
                cmd_result_check = contain
                cmd_return_value = qemu-kvm-0.12.1.2
            - qmp_query-chardev:
                qmp_cmd = "query-chardev"
                post_cmd = info chardev
                cmd_result_check = m_equal_q
            - qmp_query-blockstats:
                qmp_cmd = "query-blockstats"
                post_cmd = info blockstats
                cmd_result_check = contain
                cmd_return_value = "device;wr_highest_offset;rd_bytes;wr_operations;rd_operations;wr_bytes;parent;floppy0;sd0"
            - qmp_memsave:
                event_cmd_type = host_cmd
                qmp_cmd = "memsave val=0, size=4096, filename=memsave"
                pre_cmd = rm -rf memsave
                post_cmd = ls memsave
                cmd_result_check = post_contain
                cmd_return_value = memsave
            - qmp_pmemsave:
                event_cmd_type = host_cmd
                qmp_cmd = "pmemsave val=0, size=4096, filename=pmemsave"
                pre_cmd = rm -rf pmemsave
                post_cmd = ls pmemsave
                cmd_result_check = post_contain
                cmd_return_value = pmemsave
            - qmp_query-cpus:
                qmp_cmd = "query-cpus"
                post_cmd = "info cpus"
                cmd_result_check = m_equal_q
                event_cmd_type = monitor_cmd
            - qmp_cpu:
                event_cmd_type = qmp_cmd
                smp = 2
                pre_cmd = "cpu index=1"
                qmp_cmd = "query-cpus"
                cmd_result_check = contain
                cmd_return_value = 'current': True; u'CPU': 1
            - qmp_query-vnc:
                pre_cmd = change vnc 127.0.0.1:100
                event_cmd_type = monitor_cmd
                cmd_result_check = contain
                cmd_return_value = u'enabled'
                qmp_cmd = "query-vnc"
                post_cmd = "info vnc"
            - qmp_query-block:
                qmp_cmd = "query-block"
                post_cmd = info block
                cmd_result_check = m_equal_q
            - qmp_query-commands:
                qmp_cmd = "query-commands"
                cmd_result_check = contain
                cmd_return_value = "balloon;cont;stop"
            - qmp_query-balloon:
                extra_params += " -balloon virtio"
                event_cmd_type = monitor_cmd
                qmp_cmd = "query-balloon"
                post_cmd = "info balloon"
                cmd_result_check = m_equal_q
            - qmp_cont:
                qmp_cmd = cont
                pre_cmd = stop
                event_cmd_type = monitor_cmd
                post_cmd = info status
                cmd_result_check = post_contain
                cmd_return_value = "VM status: running"
            - qmp_stop:
                event_cmd_type = qmp_cmd
                pre_cmd = stop
                qmp_cmd = query-status
                post_cmd = cont
                cmd_result_check = equal
                cmd_return_value = "{u'status': u'paused', u'singlestep': False, u'running': False}"
            - qmp_device_add:
                no ide
                pre_command += "qemu-img create -f qcow2 /tmp/device_add01.qcow2 100M"
                event_cmd_type = qmp_cmd
                pre_cmd = "__com.redhat_drive_add file=/tmp/device_add01.qcow2,format=qcow2,id=device_add01"
                qmp_cmd = "device_add driver=virtio-blk-pci,drive=device_add01,id=device_add01"
                post_cmd = query-block
                cmd_result_check = post_contain
                cmd_return_value = "device_add01"
                post_command += " rm -rf /tmp/device_add01.qcow2;"
            - qmp_device_del:
                no ide
                pre_command += "qemu-img create -f qcow2 /tmp/device_del01.qcow2 100M"
                event_cmd_type = qmp_cmd
                pre_cmd = "__com.redhat_drive_add file=/tmp/device_del01.qcow2, format=qcow2, id=device_del01"
                qmp_cmd = "device_add driver=virtio-blk-pci, drive=device_del01, id=device_del01"
                post_cmd = "device_del id=device_del01"
                post_command += " rm -rf /tmp/device_del01.qcow2;"
            - qmp_block_resize:
                only virtio_blk
                no Windows
                images += " stg"
                image_name_stg = storage
                image_size_stg = 10G
                force_create_image_stg = yes
                remove_image_stg = yes
                kill_vm = yes
                qmp_cmd = "block_resize device=drive-virtio-disk2, size=32212254720"
                cmd_result_check = post_contain
                post_cmd = dmesg | grep virtio_blk
                # 62914560 512-byte logical blocks
                cmd_return_value = 62914560
                event_cmd_type = guest_cmd
            - qmp_negative:
                qmp_cmd = subcommands
                negative_test = yes
            - qmp_human-monitor-command:
                qmp_cmd = human-monitor-command command-line=info kvm
                post_cmd = info kvm
                cmd_result_check = m_in_q
            - qmp__com.redhat.drive_del:
                pre_command += "qemu-img create -f qcow2 /tmp/__com.redhat.drive_del01.qcow2 100M"
                event_cmd_type = qmp_cmd
                pre_cmd = "__com.redhat_drive_add file=/tmp/__com.redhat.drive_del01.qcow2, format=qcow2, id=com.redhat.drive_del01;query-block"
                qmp_cmd = "__com.redhat_drive_del id=com.redhat.drive_del01"
                post_cmd = "query-block"
                cmd_result_check = post_not_contain
                cmd_return_value = com.redhat.drive_del01
                post_command += " rm -rf /tmp/__com.redhat.drive_del01.qcow2;"
            - qmp_netdev_del:
                pre_cmd = netdev_add type=tap,id=netdev_del01;device_add driver=virtio-net-pci,netdev=netdev_del01,mac=11:22:33:44:5f:66,id=netdev_del002
                qmp_cmd = netdev_del id=netdev_del01
                post_cmd = query-block
                event_cmd_type = qmp_cmd
                cmd_result_check = post_not_contain
                cmd_return_value = netdev_del01:

    - change_media:
        no Windows
        type = change_media
        monitor_type = qmp
        pre_command += "dd if=/dev/urandom of=/tmp/orig bs=10M count=1 && dd if=/dev/urandom of=/tmp/new bs=10M count=1 && mkisofs -o /tmp/orig.iso /tmp/orig && mkisofs -o /tmp/new.iso /tmp/new;"
        post_command += "rm -rf /tmp/orig.iso /tmp/new.iso /tmp/orig /tmp/new;"
        orig_img_name = /tmp/orig.iso
        new_img_name = /tmp/new.iso
        cd_mount_cmd = mount %s /mnt
        cd_umount_cmd = umount /mnt
        cdrom_cd1 = /tmp/orig.iso

    - eject_media:
        no RHEL.3.9
        type = eject_media
        monitor_type = qmp
        pre_command += "dd if=/dev/urandom of=/tmp/orig bs=10M count=1 && dd if=/dev/urandom of=/tmp/new bs=10M count=1 && mkisofs -o /tmp/orig.iso /tmp/orig && mkisofs -o /tmp/new.iso /tmp/new;"
        post_command += "rm -rf /tmp/orig.iso /tmp/new.iso /tmp/orig /tmp/new;"
        new_img_name = /tmp/new.iso
        cdrom_cd1 = /tmp/orig.iso

    - iometer_windows:
        only Windows
        type = iometer_windows
        images += " disk1"
        boot_drive_disk1 = yes
        image_name_disk1 = storage
        image_size_disk1 = 1G
        force_create_image_disk1 = yes
        writefile_cmd = echo
        kill_vm = yes
        cmd_timeout = 1200
        variants:
            aio_native:
                image_aio = native
            aio_threads:
                image_aio = threads

    - iometer_performance:
        no Host_RHEL.6
        only Windows
        type = iometer_windows
        images += " disk1"
        boot_drive_disk1 = yes
        image_name_disk1 = storage
        image_size_disk1 = 10G
        force_create_image_disk1 = yes
        writefile_cmd = echo
        kill_vm = yes
        cmd_timeout = 1200
        variants:
            - msi_on:
                family = "0xf"
            - msi_off:
                family = "0xe"

    - qemu_disk_img:
        type = qemu_disk_img
        vms = ""
        check_file_cmd = md5sum
        create_file_cmd = "dd if=/dev/urandom of=%s bs=1M count=%s"
        file_base = /tmp/file_base
        file_sn1 = /tmp/file_sn1
        file_sn2 = /tmp/file_sn2
        file_sn3 = /tmp/file_sn3
        file_sn4 = /tmp/file_sn4
        file_size = 1024
        clean_cmd = rm -f
        file_create_size = 1024M
        get_size_cmd = "du -sm "
        variants:
            - convert_test:
                subcommand = convert
                variants:
                    - base:
                    - snapshot:
                        name_snapshot = sn1
                variants:
                    - to_qcow2:
                        convert_format = qcow2
                    - to_raw:
                        convert_format = raw
            - commit_test:
                subcommand = commit
                name_snapshot = sn1
            - rebase_test:
                subcommand = rebase
                name_snapshot1 = sn1
                name_snapshot2 = sn2
                variants:
                    - new_disk:
                        name_snapshot3 = sn3
                        name_disk = base_disk
                    - scenerio1:
                    - scenerio2:
                        name_snapshot3 = sn3
                        name_snapshot4 = sn4
                    - scenerio3:
                        name_snapshot3 = sn3

    - live_snapshot:
        no Host_RHEL.5
        type = live_snapshot
        kill_vm = yes
        create_sn_cmd = snapshot_blkdev
        create_cmd = "dd if=/dev/urandom of=%s bs=1M count=1024"
        file_create = /tmp/file
        clean_cmd = rm -f
        snapshot_name = live_snapshot_img
        variants:
            - with_reboot:
                subcommand = reboot
                sleep_time = 10
            - with_runtime:
                subcommand = runtime
            - with_file_transfer:
                subcommand = file_transfer
                sleep_time = 60
                filesize = 2000
                transfer_timeout = 1200
                transfer_type = remote
                tmp_dir = /tmp/

    - live_snapshot_chain:
        only qcow2
        type = live_snapshot_chain
        snapshot_chain = "image1 sn1"
        file_create_cmd = "dd if=/dev/urandom of=/home/test/%s count=1024 bs=4k conv=fsync"
        md5_cmd = md5sum /home/test/%s
        file_create =
        check_base_image =
        image_name_sn1 = "sn1"
        file_check_cmd = "ls %s"
        file_dir = "/home/test"
        dir_create_cmd = "mkdir %s; ls ."
        check_alive_cmd = "ls"
        kill_vm = yes
        remove_snapshot_images = yes
        variants:
            - pause:
                file_create = 
                pre_snapshot_cmd = {monitor:stop}
                post_snapshot_cmd = {monitor:cont}
            - update:
                post_snapshot_cmd = {shell:yum update -y}
                check_base_image_image1 = yes
            - long_chain:
                snapshot_chain = "image1 sn1 sn2 sn3 sn4 sn5 sn6 sn7 sn8 sn9 sn10 sn11 sn12 sn13 sn14 sn15 sn16 sn17 sn18 sn19 sn20"
                image_name_sn1 = "sn1"
                image_name_sn2 = "sn2"
                image_name_sn3 = "sn3"
                image_name_sn4 = "sn4"
                image_name_sn5 = "sn5"
                image_name_sn6 = "sn6"
                image_name_sn7 = "sn7"
                image_name_sn8 = "sn8"
                image_name_sn9 = "sn9"
                image_name_sn10 = "sn10"
                image_name_sn11 = "sn11"
                image_name_sn12 = "sn12"
                image_name_sn13 = "sn13"
                image_name_sn14 = "sn14"
                image_name_sn15 = "sn15"
                image_name_sn16 = "sn16"
                image_name_sn17 = "sn17"
                image_name_sn18 = "sn18"
                image_name_sn19 = "sn19"
                image_name_sn20 = "sn20"
                file_create = yes
                check_base_image_image1 = yes
            - check:
                snapshot_chain = "image1 sn1 sn2"
                image_name_sn1 = "sn1"
                image_name_sn2 = "sn2"
                file_create = yes
                check_base_image = yes
            - oops:
                post_snapshot_cmd = {shell_no_reply:echo c > /proc/sysrq-trigger}
                check_base_image = yes
                operate_timeout = 10
                check_alive_cmd = ""


    - performance:
        type = performance
        kill_vm = yes
        variants:
            - ffsb:
                MD5 = "cabfc1021c2ec6c6b168fefc84210891"
                images += " stg2"
                image_name_stg2 = storage2
                image_size_stg2 = 110G
                force_create_image = yes
                force_create_image_image1 = no
                test_timeout = 3600
                monitor_command = "mpstat -P ALL 1"
                #test_command = "ffsb examples/profile_everything"
                test_src = "http://cdnetworks-kr-1.dl.sourceforge.net/project/ffsb/ffsb/ffsb-6.0-rc2/ffsb-6.0-rc2.tar.bz2"
                compile_cmd = "./configure && make"
                prepare_cmd = " mount /dev/[sv]db /mnt"
                result_path = "/tmp/guest_test_result"
                ignore_pattern = "Linux|^(\n)"
                head_pattern = "\d+:\d+:\d+\s+[AP]M\s+(\w+)\s+"
                row_pattern = "CPU"
                variants:
                    - file_prepare:
                        prepare_cmd = "echo y|mkfs  -t ext4 /dev/[sv]db; mount /dev/[sv]db /mnt; rm -rf /mnt/ffsb1;mkdir -p /mnt/ffsb1"
                        test_patch = "ffsb_file_prepare.patch"
                        test_command = "ffsb examples/file_prepare.ffsb"
                    - sequential_reads_256k_16:
                        force_create_image = no
                        test_patch = "ffsb_sequential_reads_256k_16.patch"
                        test_command = "ffsb examples/sequential_reads_256k_16.ffsb"
                    - sequential_reads_256k_8:
                        force_create_image = no
                        test_patch = "ffsb_sequential_reads_256k_8.patch"
                        test_command = "ffsb examples/sequential_reads_256k_8.ffsb"
                    - sequential_reads_256k_1:
                        force_create_image = no
                        test_patch = "ffsb_sequential_reads_256k_1.patch"
                        test_command = "ffsb examples/sequential_reads_256k_1.ffsb"
                    - sequential_reads_8k_16:
                        force_create_image = no
                        test_patch = "ffsb_sequential_reads_8k_16.patch"
                        test_command = "ffsb examples/sequential_reads_8k_16.ffsb"
                    - sequential_reads_8k_8:
                        force_create_image = no
                        test_patch = "ffsb_sequential_reads_8k_8.patch"
                        test_command = "ffsb examples/sequential_reads_8k_8.ffsb"
                    - sequential_reads_8k_1:
                        force_create_image = no
                        test_patch = "ffsb_sequential_reads_8k_1.patch"
                        test_command = "ffsb examples/sequential_reads_8k_1.ffsb"
                    - random_read_8k_16:
                        force_create_image = no
                        test_patch = "ffsb_random_reads_8k_16.patch"
                        test_command = "ffsb examples/random_reads_8k_16.ffsb"
                    - random_read_8k_8:
                        force_create_image = no
                        test_patch = "ffsb_random_reads_8k_8.patch"
                        test_command = "ffsb examples/random_reads_8k_8.ffsb"
                    - random_read_8k_1:
                        force_create_image = no
                        test_patch = "ffsb_random_reads_8k_1.patch"
                        test_command = "ffsb examples/random_reads_8k_1.ffsb"
                    - large_file_creates_256k_16:
                        prepare_cmd = "echo y|mkfs  -t ext4 /dev/[sv]db; mount /dev/[sv]db /mnt; rm -rf /mnt/ffsb1;mkdir -p /mnt/ffsb1"
                        test_patch = "ffsb_large_file_creates_256k_16.patch"
                        test_command = "ffsb examples/large_file_creates_256k_16.ffsb"
                    - large_file_creates_256k_8:
                        prepare_cmd = "echo y|mkfs  -t ext4 /dev/[sv]db; mount /dev/[sv]db /mnt; rm -rf /mnt/ffsb1;mkdir -p /mnt/ffsb1"
                        test_patch = "ffsb_large_file_creates_256k_8.patch"
                        test_command = "ffsb examples/large_file_creates_256k_8.ffsb"
                    - large_file_creates_256k_1:
                        prepare_cmd = "echo y|mkfs  -t ext4 /dev/[sv]db; mount /dev/[sv]db /mnt; rm -rf /mnt/ffsb1;mkdir -p /mnt/ffsb1"
                        test_patch = "ffsb_large_file_creates_256k_1.patch"
                        test_command = "ffsb examples/large_file_creates_256k_1.ffsb"
                    - large_file_creates_8k_16:
                        prepare_cmd = "echo y|mkfs  -t ext4 /dev/[sv]db; mount /dev/[sv]db /mnt; rm -rf /mnt/ffsb1;mkdir -p /mnt/ffsb1"
                        test_patch = "ffsb_large_file_creates_8k_16.patch"
                        test_command = "ffsb examples/large_file_creates_8k_16.ffsb"
                    - large_file_creates_8k_8:
                        prepare_cmd = "echo y|mkfs  -t ext4 /dev/[sv]db; mount /dev/[sv]db /mnt; rm -rf /mnt/ffsb1;mkdir -p /mnt/ffsb1"
                        test_patch = "ffsb_large_file_creates_8k_8.patch"
                        test_command = "ffsb examples/large_file_creates_8k_8.ffsb"
                    - large_file_creates_8k_1:
                        prepare_cmd = "echo y|mkfs  -t ext4 /dev/[sv]db; mount /dev/[sv]db /mnt; rm -rf /mnt/ffsb1;mkdir -p /mnt/ffsb1"
                        test_patch = "ffsb_large_file_creates_8k_1.patch"
                        test_command = "ffsb examples/large_file_creates_8k_1.ffsb"
                    - mail_server_8k_16:
                        prepare_cmd = "echo y|mkfs  -t ext4 /dev/[sv]db; mount /dev/[sv]db /mnt; rm -rf /mnt/ffsb1;mkdir -p /mnt/ffsb1"
                        test_patch = "ffsb_mail_server_8k_16.patch"
                        test_command = "ffsb examples/mail_server_8k_16.ffsb"
                    - mail_server_8k_8:
                        prepare_cmd = "echo y|mkfs  -t ext4 /dev/[sv]db; mount /dev/[sv]db /mnt; rm -rf /mnt/ffsb1;mkdir -p /mnt/ffsb1"
                        test_patch = "ffsb_mail_server_8k_8.patch"
                        test_command = "ffsb examples/mail_server_8k_8.ffsb"
                    - mail_server_8k_1:
                        prepare_cmd = "echo y|mkfs  -t ext4 /dev/[sv]db; mount /dev/[sv]db /mnt; rm -rf /mnt/ffsb1;mkdir -p /mnt/ffsb1"
                        test_patch = "ffsb_mail_server_8k_1.patch"
                        test_command = "ffsb examples/mail_server_8k_1.ffsb"
                    - random_write_8k_16:
                        prepare_cmd = "echo y|mkfs  -t ext4 /dev/[sv]db; mount /dev/[sv]db /mnt; rm -rf /mnt/ffsb1;mkdir -p /mnt/ffsb1"
                        test_patch = "ffsb_random_write_8k_16.patch"
                        test_command = "ffsb examples/random_write_8k_16.ffsb"
                    - random_write_8k_8:
                        prepare_cmd = "echo y|mkfs  -t ext4 /dev/[sv]db; mount /dev/[sv]db /mnt; rm -rf /mnt/ffsb1;mkdir -p /mnt/ffsb1"
                        test_patch = "ffsb_random_write_8k_8.patch"
                        test_command = "ffsb examples/random_write_8k_8.ffsb"
                    - random_write_8k_1:
                        prepare_cmd = "echo y|mkfs  -t ext4 /dev/[sv]db; mount /dev/[sv]db /mnt; rm -rf /mnt/ffsb1;mkdir -p /mnt/ffsb1"
                        test_patch = "ffsb_random_write_8k_1.patch"
                        test_command = "ffsb examples/random_write_8k_1.ffsb"

            - iozone:
                test_timeout = 1200
                monitor_command = "mpstat -P ALL 1"
                test_command = "./run_iozone.sh"
                test_src = "http://www.iozone.org/src/current/iozone3_373.tar"
                compile_cmd = " chmod +x run_iozone.sh; cd src/current; make linux-AMD64"
                prepare_cmd = "i=`/bin/ls /dev/[vs]db` && dd if=$i bs=64k >/dev/null && echo 1 && echo y | mkfs -t ext4 $i > /dev/null && echo 2 ; partprobe && echo 3 ; umount /mnt ; mount $i /mnt && echo 3 > /proc/sys/vm/drop_caches && sleep 3"
                result_path = "/tmp/guest_test_result"
                ignore_pattern = "Linux|^(\n)"
                head_pattern = "\d+:\d+:\d+\s+[AP]M\s+(\w+)\s+"
                row_pattern = "CPU"
                MD5 = "6ce0277d3d1769f38040b84853a3472c"
                images += " stg2"
                image_name_stg2 = storage2
                image_size_stg2 = 10G
                force_create_image = yes
                force_create_image_image1 = no
                variants:
                    - incache:
                        test_patch = "iozone_incache.patch"
                    - outcache:
                        test_patch = "iozone_outcache.patch"
                    - dio:
                        test_patch = "iozone_dio.patch"

    - kernbench2:
        only RHEL.6
        type = kernbench
        files_need = kernel
        re_result = real\s*([0-9\.]*)m([0-9\.]*)s
        result_file = /tmp/kernbench2_result.log
        kernel_link = http://fileshare.englab.nay.redhat.com/pub/section2/kvm/fyang/kernel-2.6.32-59.tar
        kernbench_link = http://fileshare.englab.nay.redhat.com/pub/section2/kvm/fyang/kernbench-0.50.tar.gz
        gcc_link = http://fileshare.englab.nay.redhat.com/pub/section2/kvm/fyang/gcc-4.4.4-14.el6.x86_64.rpm
        libgomp_link = http://fileshare.englab.nay.redhat.com/pub/section2/kvm/fyang/libgomp-4.4.4-14.el6.x86_64.rpm
        libgcc_link = http://fileshare.englab.nay.redhat.com/pub/section2/kvm/fyang/libgcc-4.4.4-14.el6.x86_64.rpm
        cpp_link = http://fileshare.englab.nay.redhat.com/pub/section2/kvm/fyang/cpp-4.4.4-14.el6.x86_64.rpm
        test_type = guest
        pre_cmd = cd /tmp/kernbench/ && tar -xvf kernel-2.6.32-59.tar
        cmd_timeout = 3600
        tmp_dir = /tmp/kernbench
        test_cmd = cd /tmp/kernbench/kernel-2.6.32/linux-2.6.32-59.x86_64 && make clean  && time make -j %s
        need_ept = no
        post_cmd = /bin/rm -rf /tmp/kernbench/
        cpu_multiplier = 2
        vms = ''
        variants:
            native_thp_2mb_host:
                post_cmd =
                pre_command += "echo always >/sys/kernel/mm/redhat_transparent_hugepage/enabled;"
                post_command += "echo never >/sys/kernel/mm/redhat_transparent_hugepage/enabled; for i in `ls /tmp/kernbench/`; do if [[ -d /tmp/kernbench/$i ]]; then /bin/rm -rf /tmp/kernbench/$i; fi; done;"
                guest_thp_cmd = yes
                test_type = host
            native_4kb_host:
                post_cmd =
                test_type = host
                post_command += " for i in `ls /tmp/kernbench/`; do if [[ -d /tmp/kernbench/$i ]]; then /bin/rm -rf /tmp/kernbench/$i; fi; done;"
            ept_on_thp_2mb_H_2mb_G:
                need_ept = yes
                guest_thp_cmd = echo always >/sys/kernel/mm/redhat_transparent_hugepage/enabled
                pre_command += "echo always >/sys/kernel/mm/redhat_transparent_hugepage/enabled;"
                post_command += "echo never >/sys/kernel/mm/redhat_transparent_hugepage/enabled;"
            ept_on_thp_2mb_H_4kb_G:
                need_ept = yes
                pre_command += "echo always >/sys/kernel/mm/redhat_transparent_hugepage/enabled;"
                post_command += "echo never >/sys/kernel/mm/redhat_transparent_hugepage/enabled;"
            ept_on_4kb_H_4kb_G:
                need_ept = yes
            ept_off_thp_2mb_H_2mb_G:
                pre_command += "echo always >/sys/kernel/mm/redhat_transparent_hugepage/enabled;"
                post_command += "echo never >/sys/kernel/mm/redhat_transparent_hugepage/enabled;"
                guest_thp_cmd = echo always >/sys/kernel/mm/redhat_transparent_hugepage/enabled
            ept_off_thp_2mb_H_4kb_G:
                pre_command += "echo always >/sys/kernel/mm/redhat_transparent_hugepage/enabled;"
                post_command += "echo never >/sys/kernel/mm/redhat_transparent_hugepage/enabled;"
            ept_off_4kb_H_4kb_G:
                post_command += " rm -rf /tmp/kernbench2_result.log;"

    - sysprep:
        only Windows
        type = sysprep
        unattended_file = win7-64-autounattend.xml
        tmp_path = C:\\
        extend_vm = " vm2"
        sysprep_cmd = c:\Windows\System32\sysprep\sysprep.exe /generalize /oobe /shutdown /unattend:%s

    - kexec:
        only Linux
        no RHEL.4
        no RHEL.3.9
        type = kexec
        enable_x2apic = yes
        check_x2apic = yes
        rpm_timeout = 1200
        args_removed = "rhgb quiet"
        args_added = "console=ttyS0,115200 console=tty0"
        method = brew
        kernel_count_cmd = grep 'title' /boot/grub/grub.conf | wc -l
        load_kernel_cmd = kexec -l %s --initrd=%s --command-line="`cat /proc/cmdline`"
        kexec_reboot_cmd = kexec -e
        check_installed_kernel = rpm -q kernel
        get_kernel_image = ls /boot/vmlin*|grep %s
        get_kernel_ramdisk = ls /boot/init*|grep %s
        check_cur_kernel_cmd = uname -r

    - boot_time:
        only Linux
        vms = ""
        type = boot_time
        shutdown_method = system_powerdown
        kill_vm = yes
        kill_vm_gracefully = no
        check_img = yes
        # This value may change from host to host
        # Please confirm your host status and update it
        # expect_bootup_time = 16

    - virtio_driver_sign_check:
        only Win7.64
        # This script only need run once for every virtio driver version.
        # So need not add to our testing loop.
        type = virtio_driver_sign_check
        cdroms += " sdk virtio"
        cdrom_virtio = /usr/share/virtio-win/virtio-win.iso
        cdrom_sdk = isos/windows/GRMSDKX_EN_DVD.iso
        floppy = "/usr/share/virtio-win/virtio-win.vfd"
        list_files_cmd = dir /s /b %s | find "%s"
        winsdk_au3 = autoit/winsdk.au3
        signtool_install = "D:\autoit3.exe c:\winsdk.au3"
        signtool_cmd = "c:\Program Files\Microsoft SDKs\Windows\v7.0\Bin\signtool.exe" verify /v /kp /c %s %s
        drive_list = F: A:

    - cluster_size_check:
        no Host_RHEL.5
        only qcow2
        type = cluster_size_check
        vms = ""
        images = "cluster"
        image_name_cluster = "cluster_size_check"
        image_size_cluster = 1G
        remove_image_cluster = "yes"
        cluster_size_parttern = "cluster_size=(\d+)"
        cluster_size_set = "default 4k"

    - qemu_io_blkdebug:
        only qcow2
        type = qemu_io_blkdebug
        vms = ""
        images = "blk"
        image_name_blk = "blkdebug"
        image_size_blk = 20G
        image_format_blk = qcow2
        remove_image_blk = yes
        cluster_size = 512
        err_command = "write 0 1G"
        err_event = "refblock_alloc"
        errn_list = "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28"
        re_stand = "error\s+code\s+\d+:\s+([a-zA-Z\/\-\s]+)$"
        test_timeout = 720
        variants:
            - refblock_update_part:
                image_size_blk = 1G
                err_event = "refblock_update_part"
                err_command = "write -b 0 1G"
            - cluster_alloc:
                image_size_blk = 20G
                err_event = "cluster_alloc"
                err_command = "write -b 0 1G"
            - vmstate_load:
                pre_err_commands = "read -b 0 1G"
                image_size_blk = 10G
                err_event = "vmstate_load"
                err_command = "write -b 0 1G"
            - l1_grow_alloc_table:
                image_size_blk = 20G
                err_event = "l1_grow.alloc_table"
                err_command = "write -b 0 1G"
            - l1_grow_activate_table:
                image_size_blk = 20G
                err_event = "l1_grow.activate_table"
                err_command = "write -b 0 1G"
            - refblock_alloc_write:
                image_size_blk = 20G
                err_event = "refblock_alloc.write"
                err_command = "write -b 0 1G"
            - write_aio:
                image_size_blk = 10G
                err_event = "write_aio"
                err_command = "write 0 100M -P 1"
            - vmstate_save:
                image_size_blk = 10G
                err_event = "vmstate_save"
                err_command = "write -b 0 10k -P 1"
            - reftable_grow:
                image_size_blk = 20G
                err_event = "reftable_grow"
                err_command = "write -b 0 1G"
            - refblock_load:
                image_size_blk = 20G
                err_event = "refblock_load"
                err_command = "write -b 0 1G"
            - refblock_alloc_write_table:
                image_size_blk = 20G
                err_event = "refblock_alloc.write_table"
                err_command = "write -b 0 1G"
            - refblock_alloc_switch_table:
                image_size_blk = 20G
                err_event = "refblock_alloc.switch_table"
                err_command = "write -b 0 1G"
            - refblock_alloc_hookup:
                image_size_blk = 20G
                err_event = "refblock_alloc.hookup"
                err_command = "write -b 0 1G"
            - read_aio:
                pre_err_commands = "write -b 0 66M"
                image_size_blk = 10G
                err_event = "read_aio"
                err_command = "read -b 0 66M"
            - l2_update:
                image_size_blk = 20G
                err_event = "l2_update"
                err_command = "write -b 0 1G"
            - l2_alloc_write:
                image_size_blk = 20G
                err_event = "l2_alloc.write"
                err_command = "write -b 0 1G"
            - l1_update:
                image_size_blk = 20G
                err_event = "l1_update"
                err_command = "write -b 0 1G"
            - l1_grow_write_table:
                image_size_blk = 20G
                err_event = "l1_grow.write_table"
                err_command = "write -b 0 1G"
            - refblock_alloc:
                image_size_blk = 20G
                err_event = "refblock_alloc"
                err_command = "write -b 0 1G"

    - nfs_perf:
        only virtio_nic
        only Linux
        type = nfs_perf
        nfs_server = 192.168.0.113
        nfs_path = "/vol/s2wquan116171nfs"
        mnt_option = "rw,bg,hard,nointr,rsize=65536,wsize=65536,tcp,noac,vers=3,timeo=600"
        blk_size_list = "4k 8k 16k"

 # Internal case configuration end. Don't add any case below this line.
 # (THIS LINE IS RESERVED FOR MERGE)
 # (THIS LINE IS RESERVED FOR MERGE)
# Internal case configuration end. Don't add any case below this line.
# (THIS LINE IS RESERVED FOR MERGE)
# (THIS LINE IS RESERVED FOR MERGE)
# (THIS LINE IS RESERVED FOR MERGE)

# URLs/Remote links for RHEL installation and update, put them together.
unattended_install.url:
    RHEL.6.3.64:
        url = http://tree.englab.nay.redhat.com/pub/rhel/rel-eng/RHEL6.3/RHEL6.3-latest/x86_64/os/ 
    RHEL.6.3.32:
        url = http://tree.englab.nay.redhat.com/pub/rhel/rel-eng/RHEL6.3/RHEL6.3-latest/i386/os/ 
    RHEL.6.2.64:
        url = http://download.englab.nay.redhat.com/pub/rhel/released/RHEL-6/6.2/Server/x86_64/os/
    RHEL.6.2.32:
        url = http://download.englab.nay.redhat.com/pub/rhel/released/RHEL-6/6.2/Server/i386/os/
    RHEL.6.1.64:
        url = http://download.englab.nay.redhat.com/pub/rhel/released/RHEL-6/6.1/Server/x86_64/os/
    RHEL.6.1.32:
        url = http://download.englab.nay.redhat.com/pub/rhel/released/RHEL-6/6.1/Server/i386/os/
    RHEL.5.9.64:
        url = http://download.englab.nay.redhat.com/pub/rhel/rel-eng/latest-RHEL-5-Server/tree-x86_64/
    RHEL.5.9.32:
        url = http://download.englab.nay.redhat.com/pub/rhel/rel-eng/latest-RHEL-5-Server/tree-i386/
    RHEL.5.8.64:
        url = http://download.englab.nay.redhat.com/pub/rhel/released/RHEL-5-Server/U8/x86_64/os/
    RHEL.5.8.32:
        url = http://download.englab.nay.redhat.com/pub/rhel/released/RHEL-5-Server/U8/i386/os/
    RHEL.5.7.64:
        url = http://download.englab.nay.redhat.com/pub/rhel/released/RHEL-5-Server/U7/x86_64/os/
    RHEL.5.7.32:
        url = http://download.englab.nay.redhat.com/pub/rhel/released/RHEL-5-Server/U7/i386/os/
    RHEL.4.9.64:
        url = http://download.englab.nay.redhat.com/pub/rhel/released/RHEL-4/U9/AS/x86_64/tree/
    RHEL.4.9.32:
        url = http://download.englab.nay.redhat.com/pub/rhel/released/RHEL-4/U9/AS/i386/tree/
    RHEL.3.9.64:
        url = http://tree.englab.nay.redhat.com/pub/rhel/released/RHEL-3/U9/x86_64/os/
    RHEL.3.9.32:
        url = http://tree.englab.nay.redhat.com/pub/rhel/released/RHEL-3/U9/i386/os/

unattended_install.nfs:
    nfs_server = nfs.englab.nay.redhat.com
    nfs_dir = /pub/rhel/released/
    RHEL.6.3.64:
        nfs_server = tree.englab.nay.redhat.com
        nfs_dir = /tree/pub/rhel/rel-eng/RHEL6.3/RHEL6.3-latest/x86_64/os
    RHEL.6.3.32:
        nfs_server = tree.englab.nay.redhat.com
        nfs_dir = /tree/pub/rhel/rel-eng/RHEL6.3/RHEL6.3-latest/i386/os
    RHEL.6.2.64:
        nfs_dir += RHEL-6/6.2/Server/x86_64/os
    RHEL.6.2.32:
        nfs_dir += RHEL-6/6.2/Server/i386/os
    RHEL.6.1.64:
        nfs_dir += RHEL-6/6.1/Server/x86_64/os
    RHEL.6.1.32:
        nfs_dir += RHEL-6/6.1/Server/i386/os
    RHEL.5.9.64:
        nfs_dir = /pub/rhel/rel-eng/latest-RHEL-5-Server/tree-x86_64
    RHEL.5.9.32:
        nfs_dir = /pub/rhel/rel-eng/latest-RHEL-5-Server/tree-i386
    RHEL.5.8.64:
        nfs_dir += RHEL-5-Server/U8/x86_64/os
    RHEL.5.8.32:
        nfs_dir += RHEL-5-Server/U8/i386/os
    RHEL.5.7.64:
        nfs_dir += RHEL-5-Server/U7/x86_64/os
    RHEL.5.7.32:
        nfs_dir += RHEL-5-Server/U7/i386/os
    RHEL.4.9.64:
        nfs_dir += RHEL-4/U9/AS/x86_64/tree
    RHEL.4.9.32:
        nfs_dir += RHEL-4/U9/AS/i386/tree
    RHEL.3.9.64:
        nfs_server = tree.englab.nay.redhat.com
        nfs_dir = /tree/pub/rhel/released/RHEL-3/U9/x86_64/os/
    RHEL.3.9.32:
        nfs_server = tree.englab.nay.redhat.com
        nfs_dir = /tree/pub/rhel/released/RHEL-3/U9/i386/os/

rh_kernel_update, kexec:
    RHEL.6.3.64:
        kernel_version = 2.6.32-221.el6.x86_64
        kernel_rpm = http://download.devel.redhat.com/brewroot/packages/kernel/2.6.32/221.el6/x86_64/kernel-2.6.32-221.el6.x86_64.rpm
        kernel_suffix = el6.x86_64
    RHEL.6.3.32:
        kernel_version = 2.6.32-221.el6.i686
        kernel_rpm = http://download.devel.redhat.com/brewroot/packages/kernel/2.6.32/221.el6/i686/kernel-2.6.32-221.el6.i686.rpm
        kernel_suffix = el6.i686
    RHEL.6.2.64:
        kernel_version = 2.6.32-220.el6.x86_64
        kernel_rpm = http://download.devel.redhat.com/brewroot/packages/kernel/2.6.32/220.el6/x86_64/kernel-2.6.32-220.el6.x86_64.rpm
        kernel_suffix = el6.x86_64
    RHEL.6.2.32:
        kernel_version = 2.6.32-220.el6.i686
        kernel_rpm = http://download.devel.redhat.com/brewroot/packages/kernel/2.6.32/220.el6/i686/kernel-2.6.32-220.el6.i686.rpm
        kernel_suffix = el6.i686
    RHEL.6.1.64:
        kernel_version = 2.6.32-131.0.15.el6.x86_64
        kernel_rpm = http://download.devel.redhat.com/brewroot/packages/kernel/2.6.32/131.0.15.el6/x86_64/kernel-2.6.32-131.0.15.el6.x86_64.rpm
        kernel_suffix = el6.x86_64
    RHEL.6.1.32:
        kernel_version = 2.6.32-131.0.15.el6.i686
        kernel_rpm = http://download.devel.redhat.com/brewroot/packages/kernel/2.6.32/131.0.15.el6/i686/kernel-2.6.32-131.0.15.el6.i686.rpm
        kernel_suffix = el6.i686
    RHEL.5.8.64:
        kernel_version = 2.6.18-298.el5
        kernel_rpm = http://download.devel.redhat.com/brewroot/packages/kernel/2.6.18/298.el5/x86_64/kernel-2.6.18-298.el5.x86_64.rpm
        kernel_suffix = el5
    RHEL.5.8.PAE:
        kernel_version = 2.6.18-298.el5PAE
        kernel_rpm = http://download.devel.redhat.com/brewroot/packages/kernel/2.6.18/298.el5/i686/kernel-PAE-2.6.18-298.el5.i686.rpm
        kernel_suffix = el5PAE
    RHEL.5.8.32:
        kernel_version = 2.6.18-298.el5
        kernel_rpm = http://download.devel.redhat.com/brewroot/packages/kernel/2.6.18/298.el5/i686/kernel-2.6.18-298.el5.i686.rpm
        kernel_suffix = el5
    RHEL.5.7.64:
        kernel_version = 2.6.18-274.el5
        kernel_rpm = http://download.devel.redhat.com/brewroot/packages/kernel/2.6.18/274.el5/x86_64/kernel-2.6.18-274.el5.x86_64.rpm
        kernel_suffix = el5
    RHEL.5.7.PAE:
        kernel_version = 2.6.18-274.el5PAE
        kernel_rpm = http://download.devel.redhat.com/brewroot/packages/kernel/2.6.18/274.el5/i686/kernel-PAE-2.6.18-274.el5.i686.rpm
        kernel_suffix = el5PAE
    RHEL.5.7.32:
        kernel_version = 2.6.18-274.el5
        kernel_rpm = http://download.devel.redhat.com/brewroot/packages/kernel/2.6.18/274.el5/i686/kernel-2.6.18-274.el5.i686.rpm
        kernel_suffix = el5
    RHEL.4.9.32:
        kernel_version = 2.6.9-100.ELsmp
        kernel_rpm = http://download.devel.redhat.com/brewroot/packages/kernel/2.6.9/100.EL/i686/kernel-smp-2.6.9-100.EL.i686.rpm
        kernel_suffix = ELsmp
        kernel_re = .*kernel-smp-%s.EL.i686.*
    RHEL.4.9.PAE:
        kernel_version = 2.6.9-100.ELhugemem
        kernel_rpm = http://download.devel.redhat.com/brewroot/packages/kernel/2.6.9/100.EL/i686/kernel-hugemem-2.6.9-100.EL.i686.rpm
        kernel_suffix = ELhugemem
        kernel_re = .*kernel-hugemem-%s.EL.i686.*
    RHEL.4.9.64:
        kernel_version = 2.6.9-100.ELsmp
        kernel_rpm = http://download.devel.redhat.com/brewroot/packages/kernel/2.6.9/100.EL/x86_64/kernel-smp-2.6.9-100.EL.x86_64.rpm
        kernel_suffix = ELsmp
        kernel_re = .*kernel-smp-%s.EL.x86_64.*
